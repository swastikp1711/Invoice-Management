// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { createTracingClient } from "@azure/core-tracing";
import { FORM_RECOGNIZER_API_VERSION, SDK_VERSION } from "./constants";
import { accept1 } from "./generated/models/parameters";
import { toAnalyzeResultFromGenerated, toDocumentAnalysisPollOperationState, } from "./lro/analysis";
import { lro } from "./lro/util/poller";
import { makeServiceClient, Mappers, SERIALIZER } from "./util";
/**
 * A client for interacting with the Form Recognizer service's analysis features.
 *
 * ### Examples:
 *
 * The Form Recognizer service and clients support two means of authentication:
 *
 * #### Azure Active Directory
 *
 * ```javascript
 * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```javascript
 * import { DocumentAnalysisClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 */
export class DocumentAnalysisClient {
    constructor(endpoint, credential, options = {}) {
        this._restClient = makeServiceClient(endpoint, credential, options);
        this._tracing = createTracingClient({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    async beginAnalyzeDocument(model, document, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocument", options, 
        // In the first version of the SDK, the document input was treated as a URL if it was a string, and we preserve
        // this behavior to avoid introducing a breaking change.
        this.analyze.bind(this, model, typeof document === "string" ? source("url", document) : source("body", document)));
    }
    async beginAnalyzeDocumentFromUrl(model, documentUrl, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocumentFromUrl", options, this.analyze.bind(this, model, source("url", documentUrl)));
    }
    /**
     * A helper method for running analysis polymorphically.
     *
     * @param model - the model ID or DocumentModel to use for analysis
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns - an analysis poller
     */
    analyze(model, input, options) {
        const { modelId: initialModelId, apiVersion: requestApiVersion, transformResult, } = typeof model === "string"
            ? { modelId: model, apiVersion: undefined, transformResult: (v) => v }
            : model;
        if (requestApiVersion && requestApiVersion !== FORM_RECOGNIZER_API_VERSION) {
            throw new Error([
                `API Version mismatch: the provided model wants version: ${requestApiVersion},`,
                `but the client is using ${FORM_RECOGNIZER_API_VERSION}.`,
                "The API version of the model must match the client's API version.",
            ].join(" "));
        }
        return this.createUnifiedPoller((abortSignal) => {
            const [contentType, analyzeRequest] = toAnalyzeRequest(input);
            return this._restClient.documentModels.analyzeDocument(initialModelId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                analyzeRequest }));
        }, {
            initialModelId,
            options,
            transformResult: (result) => transformResult(toAnalyzeResultFromGenerated(result)),
        });
    }
    /**
     * Classify a document using a custom classifier given by its ID.
     *
     * This method produces a long-running operation (poller) that will eventually produce an `AnalyzeResult`. This is the
     * same type as `beginAnalyzeDocument` and `beginAnalyzeDocumentFromUrl`, but the result will only contain a small
     * subset of its fields. Only the `documents` field and `pages` field will be populated, and only minimal page
     * information will be returned. The `documents` field will contain information about all the identified documents and
     * the `docType` that they were classified as.
     *
     * ### Example
     *
     * This method supports streamable request bodies ({@link FormRecognizerRequestBody}) such as Node.JS `ReadableStream`
     * objects, browser `Blob`s, and `ArrayBuffer`s. The contents of the body will be uploaded to the service for analysis.
     *
     * ```typescript
     * import * as fs from "fs";
     *
     * const file = fs.createReadStream("path/to/file.pdf");
     *
     * const poller = await client.beginClassifyDocument("<classifier ID>", file);
     *
     * // The result is a long-running operation (poller), which must itself be polled until the operation completes
     * const {
     *   pages, // pages extracted from the document, which contain only basic information for classifiers
     *   documents // extracted documents and their types
     * } = await poller.pollUntilDone();
     *
     * // We'll print the documents and their types
     * for (const { docType } of documents) {
     *   console.log("The type of this document is:", docType);
     * }
     * ```
     *
     * @param classifierId - the ID of the custom classifier to use for analysis
     * @param document - the document to classify
     * @param options - options for the classification operation
     * @returns a long-running operation (poller) that will eventually produce an `AnalyzeResult`
     */
    async beginClassifyDocument(classifierId, document, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginClassifyDocument", options, this.classify.bind(this, classifierId, source("body", document)));
    }
    /**
     * Classify a document from a URL using a custom classifier given by its ID.
     *
     * This method produces a long-running operation (poller) that will eventually produce an `AnalyzeResult`. This is the
     * same type as `beginAnalyzeDocument` and `beginAnalyzeDocumentFromUrl`, but the result will only contain a small
     * subset of its fields. Only the `documents` field and `pages` field will be populated, and only minimal page
     * information will be returned. The `documents` field will contain information about all the identified documents and
     * the `docType` that they were classified as.
     *
     * ### Example
     *
     * This method supports extracting data from a file at a given URL. The Form Recognizer service will attempt to
     * download a file using the submitted URL, so the URL must be accessible from the public internet. For example, a SAS
     * token can be used to grant read access to a blob in Azure Storage, and the service will use the SAS-encoded URL to
     * request the file.
     *
     * ```typescript
     * // the URL must be publicly accessible
     * const url = "<file url>";
     *
     * const poller = await client.beginClassifyDocument("<classifier ID>", url);
     *
     * // The result is a long-running operation (poller), which must itself be polled until the operation completes
     * const {
     *   pages, // pages extracted from the document, which contain only basic information for classifiers
     *   documents // extracted documents and their types
     * } = await poller.pollUntilDone();
     *
     * // We'll print the documents and their types
     * for (const { docType } of documents) {
     *   console.log("The type of this document is:", docType);
     * }
     * ```
     * @param classifierId - the ID of the custom classifier to use for analysis
     * @param documentUrl - the URL of the document to classify
     * @param options -
     * @returns
     */
    async beginClassifyDocumentFromUrl(classifierId, documentUrl, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginClassifyDocumentFromUrl", options, this.classify.bind(this, classifierId, source("url", documentUrl)));
    }
    /**
     * A helper method for running classification polymorphically.
     * @param classifierId - the ID of the classifier to use
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns an analysis poller
     */
    classify(classifierId, input, options) {
        return this.createUnifiedPoller(async (abortSignal) => {
            const [contentType, classifyRequest] = toAnalyzeRequest(input);
            return this._restClient.documentClassifiers.classifyDocument(classifierId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                classifyRequest }));
        }, {
            initialModelId: classifierId,
            options,
            transformResult: toAnalyzeResultFromGenerated,
        });
    }
    /**
     * Create an LRO poller that handles analysis operations.
     *
     * This is the meat of all analysis polling operations.
     *
     * @param startOperation - function that starts the operation and returns the operation location
     * @param definition - operation definition (initial model ID, operation transforms, request options)
     * @returns - an analysis poller that produces the given return types according to the operation spec
     */
    async createUnifiedPoller(startOperation, definition) {
        const { resumeFrom } = definition.options;
        // TODO: what should we do if resumeFrom.modelId is different from initialModelId?
        // And what do we do with the redundant input??
        const getAnalyzeResult = (ctx, operationLocation) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-getAnalyzeResult", definition.options, (finalOptions) => this._restClient.sendOperationRequest({
            options: Object.assign(Object.assign({ onResponse: async (rawResponse, ...args) => {
                    var _a;
                    // Capture the `Retry-After` header if it was sent.
                    const retryAfterHeader = rawResponse.headers.get("retry-after");
                    // Convert the header value to milliseconds. If the header is not a valid number, then it is an HTTP
                    // date.
                    if (retryAfterHeader) {
                        const retryAfterMs = Number(retryAfterHeader) * 1000;
                        if (!Number.isNaN(retryAfterMs)) {
                            ctx.updateDelay(retryAfterMs);
                        }
                        else {
                            ctx.updateDelay(Date.parse(retryAfterHeader) - Date.now());
                        }
                    }
                    else {
                        ctx.updateDelay(undefined);
                    }
                    // Forward the `onResponse` callback if it was provided.
                    return (_a = finalOptions.onResponse) === null || _a === void 0 ? void 0 : _a.call(finalOptions, rawResponse, ...args);
                } }, finalOptions), { 
                // We need to pass the abort signal from the context rather than from the options, since the user could
                // poll the LRO with a different AbortSignal than it was instantiated with.
                abortSignal: ctx.abortSignal }),
        }, {
            path: operationLocation,
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: Mappers.AnalyzeResultOperation,
                },
                default: {
                    bodyMapper: Mappers.ErrorResponse,
                },
            },
            // URL is fully-formed, so we don't need any query parameters
            headerParameters: [accept1],
            serializer: SERIALIZER,
        }));
        const toInit = 
        // If the user gave us a stored token, we'll poll it again
        resumeFrom !== undefined
            ? async (ctx) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-resume", definition.options, async () => {
                const { clientVersion, operationLocation, modelId } = JSON.parse(resumeFrom);
                if (!clientVersion || clientVersion !== SDK_VERSION) {
                    throw new Error([
                        "Cannot restore poller from a serialized state from a different version of the client",
                        `library (restoreFrom: '${clientVersion}', current: '${SDK_VERSION}').`,
                    ].join(" "));
                }
                const result = await getAnalyzeResult(ctx, operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            })
            : // Otherwise, we'll start a new operation from the initialModelId
                async (ctx) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-start", definition.options, async () => {
                    const { operationLocation } = await startOperation(ctx.abortSignal);
                    if (operationLocation === undefined) {
                        throw new Error("Unable to start analysis operation: no Operation-Location received.");
                    }
                    const result = await getAnalyzeResult(ctx, operationLocation);
                    return toDocumentAnalysisPollOperationState(definition, definition.initialModelId, operationLocation, result);
                });
        const poller = await lro({
            init: toInit,
            poll: async (ctx, { operationLocation, modelId }) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-poll", {}, async () => {
                const result = await getAnalyzeResult(ctx, operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            }),
            serialize: ({ operationLocation, modelId }) => JSON.stringify({ clientVersion: SDK_VERSION, id: modelId, operationLocation }),
        }, definition.options.updateIntervalInMs, definition.options.abortSignal);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        return poller;
    }
}
/**
 * Produce an appropriate pair of content-type and analyzeRequest value for the analysis request.
 * @internal
 */
function toAnalyzeRequest(input) {
    switch (input.kind) {
        case "body":
            return ["application/octet-stream", input.body];
        case "url":
            return ["application/json", { urlSource: input.url }];
        case "base64":
            return ["application/json", { base64Source: input.base64 }];
        default: {
            const __exhaust = input;
            throw new Error(`Unreachable 'toAnalyzeRequest' case: ${__exhaust}`);
        }
    }
}
/**
 * The input to a document analysis operation.
 */
// type DocumentSource = DocumentBodySource | DocumentUrlSource | DocumentBase64Source;
function source(kind, value) {
    return {
        kind,
        [kind]: value,
    };
}
//# sourceMappingURL=documentAnalysisClient.js.map