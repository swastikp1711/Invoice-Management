'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var coreTracing = require('@azure/core-tracing');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var abortController = require('@azure/abort-controller');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);
var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The default AAD permissions scope for Cognitive Services.
 * @internal
 */
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * @internal
 */
const SDK_VERSION = "5.0.0";
const FORM_RECOGNIZER_API_VERSION = "2023-07-31";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AnalyzeDocumentRequest = {
    type: {
        name: "Composite",
        className: "AnalyzeDocumentRequest",
        modelProperties: {
            urlSource: {
                serializedName: "urlSource",
                type: {
                    name: "String"
                }
            },
            base64Source: {
                serializedName: "base64Source",
                type: {
                    name: "ByteArray"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const AnalyzeResultOperation = {
    type: {
        name: "Composite",
        className: "AnalyzeResultOperation",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["notStarted", "running", "failed", "succeeded"]
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            analyzeResult: {
                serializedName: "analyzeResult",
                type: {
                    name: "Composite",
                    className: "AnalyzeResult"
                }
            }
        }
    }
};
const AnalyzeResult = {
    type: {
        name: "Composite",
        className: "AnalyzeResult",
        modelProperties: {
            apiVersion: {
                serializedName: "apiVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                required: true,
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            pages: {
                serializedName: "pages",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentPage"
                        }
                    }
                }
            },
            paragraphs: {
                serializedName: "paragraphs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentParagraph"
                        }
                    }
                }
            },
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentTable"
                        }
                    }
                }
            },
            keyValuePairs: {
                serializedName: "keyValuePairs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentKeyValuePair"
                        }
                    }
                }
            },
            styles: {
                serializedName: "styles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentStyle"
                        }
                    }
                }
            },
            languages: {
                serializedName: "languages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLanguage"
                        }
                    }
                }
            },
            documents: {
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Document"
                        }
                    }
                }
            }
        }
    }
};
const DocumentPage = {
    type: {
        name: "Composite",
        className: "DocumentPage",
        modelProperties: {
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "pageNumber",
                required: true,
                type: {
                    name: "Number"
                }
            },
            angle: {
                constraints: {
                    InclusiveMaximum: 180,
                    ExclusiveMinimum: -180
                },
                serializedName: "angle",
                type: {
                    name: "Number"
                }
            },
            width: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "width",
                type: {
                    name: "Number"
                }
            },
            height: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "height",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            words: {
                serializedName: "words",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentWord"
                        }
                    }
                }
            },
            selectionMarks: {
                serializedName: "selectionMarks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSelectionMark"
                        }
                    }
                }
            },
            lines: {
                serializedName: "lines",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLine"
                        }
                    }
                }
            },
            barcodes: {
                serializedName: "barcodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentBarcode"
                        }
                    }
                }
            },
            formulas: {
                serializedName: "formulas",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentFormula"
                        }
                    }
                }
            }
        }
    }
};
const DocumentSpan = {
    type: {
        name: "Composite",
        className: "DocumentSpan",
        modelProperties: {
            offset: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentWord = {
    type: {
        name: "Composite",
        className: "DocumentWord",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            span: {
                serializedName: "span",
                type: {
                    name: "Composite",
                    className: "DocumentSpan"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentSelectionMark = {
    type: {
        name: "Composite",
        className: "DocumentSelectionMark",
        modelProperties: {
            state: {
                serializedName: "state",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            span: {
                serializedName: "span",
                type: {
                    name: "Composite",
                    className: "DocumentSpan"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentLine = {
    type: {
        name: "Composite",
        className: "DocumentLine",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentBarcode = {
    type: {
        name: "Composite",
        className: "DocumentBarcode",
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            span: {
                serializedName: "span",
                type: {
                    name: "Composite",
                    className: "DocumentSpan"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentFormula = {
    type: {
        name: "Composite",
        className: "DocumentFormula",
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            span: {
                serializedName: "span",
                type: {
                    name: "Composite",
                    className: "DocumentSpan"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentParagraph = {
    type: {
        name: "Composite",
        className: "DocumentParagraph",
        modelProperties: {
            role: {
                serializedName: "role",
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const BoundingRegion = {
    type: {
        name: "Composite",
        className: "BoundingRegion",
        modelProperties: {
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "pageNumber",
                required: true,
                type: {
                    name: "Number"
                }
            },
            polygon: {
                serializedName: "polygon",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const DocumentTable = {
    type: {
        name: "Composite",
        className: "DocumentTable",
        modelProperties: {
            rowCount: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "rowCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            columnCount: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "columnCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            cells: {
                serializedName: "cells",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentTableCell"
                        }
                    }
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentTableCell = {
    type: {
        name: "Composite",
        className: "DocumentTableCell",
        modelProperties: {
            kind: {
                defaultValue: "content",
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            rowIndex: {
                serializedName: "rowIndex",
                required: true,
                type: {
                    name: "Number"
                }
            },
            columnIndex: {
                serializedName: "columnIndex",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rowSpan: {
                defaultValue: 1,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "rowSpan",
                type: {
                    name: "Number"
                }
            },
            columnSpan: {
                defaultValue: 1,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "columnSpan",
                type: {
                    name: "Number"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentKeyValuePair = {
    type: {
        name: "Composite",
        className: "DocumentKeyValuePair",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "DocumentKeyValueElement"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "DocumentKeyValueElement"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentKeyValueElement = {
    type: {
        name: "Composite",
        className: "DocumentKeyValueElement",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentStyle = {
    type: {
        name: "Composite",
        className: "DocumentStyle",
        modelProperties: {
            isHandwritten: {
                serializedName: "isHandwritten",
                type: {
                    name: "Boolean"
                }
            },
            similarFontFamily: {
                serializedName: "similarFontFamily",
                type: {
                    name: "String"
                }
            },
            fontStyle: {
                serializedName: "fontStyle",
                type: {
                    name: "String"
                }
            },
            fontWeight: {
                serializedName: "fontWeight",
                type: {
                    name: "String"
                }
            },
            color: {
                constraints: {
                    Pattern: new RegExp("^#[0-9a-f]{6}$")
                },
                serializedName: "color",
                type: {
                    name: "String"
                }
            },
            backgroundColor: {
                constraints: {
                    Pattern: new RegExp("^#[0-9a-f]{6}$")
                },
                serializedName: "backgroundColor",
                type: {
                    name: "String"
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentLanguage = {
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            locale: {
                serializedName: "locale",
                required: true,
                type: {
                    name: "String"
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Document = {
    type: {
        name: "Composite",
        className: "Document",
        modelProperties: {
            docType: {
                constraints: {
                    MaxLength: 64,
                    MinLength: 2
                },
                serializedName: "docType",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "DocumentField" } }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentField = {
    type: {
        name: "Composite",
        className: "DocumentField",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            valueString: {
                serializedName: "valueString",
                type: {
                    name: "String"
                }
            },
            valueDate: {
                serializedName: "valueDate",
                type: {
                    name: "Date"
                }
            },
            valueTime: {
                serializedName: "valueTime",
                type: {
                    name: "String"
                }
            },
            valuePhoneNumber: {
                serializedName: "valuePhoneNumber",
                type: {
                    name: "String"
                }
            },
            valueNumber: {
                serializedName: "valueNumber",
                type: {
                    name: "Number"
                }
            },
            valueInteger: {
                serializedName: "valueInteger",
                type: {
                    name: "Number"
                }
            },
            valueSelectionMark: {
                serializedName: "valueSelectionMark",
                type: {
                    name: "String"
                }
            },
            valueSignature: {
                serializedName: "valueSignature",
                type: {
                    name: "String"
                }
            },
            valueCountryRegion: {
                serializedName: "valueCountryRegion",
                type: {
                    name: "String"
                }
            },
            valueArray: {
                serializedName: "valueArray",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentField"
                        }
                    }
                }
            },
            valueObject: {
                serializedName: "valueObject",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "DocumentField" } }
                }
            },
            valueCurrency: {
                serializedName: "valueCurrency",
                type: {
                    name: "Composite",
                    className: "CurrencyValue"
                }
            },
            valueAddress: {
                serializedName: "valueAddress",
                type: {
                    name: "Composite",
                    className: "AddressValue"
                }
            },
            valueBoolean: {
                serializedName: "valueBoolean",
                type: {
                    name: "Boolean"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CurrencyValue = {
    type: {
        name: "Composite",
        className: "CurrencyValue",
        modelProperties: {
            amount: {
                serializedName: "amount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            currencySymbol: {
                serializedName: "currencySymbol",
                type: {
                    name: "String"
                }
            },
            currencyCode: {
                serializedName: "currencyCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddressValue = {
    type: {
        name: "Composite",
        className: "AddressValue",
        modelProperties: {
            houseNumber: {
                serializedName: "houseNumber",
                type: {
                    name: "String"
                }
            },
            poBox: {
                serializedName: "poBox",
                type: {
                    name: "String"
                }
            },
            road: {
                serializedName: "road",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            postalCode: {
                serializedName: "postalCode",
                type: {
                    name: "String"
                }
            },
            countryRegion: {
                serializedName: "countryRegion",
                type: {
                    name: "String"
                }
            },
            streetAddress: {
                serializedName: "streetAddress",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            cityDistrict: {
                serializedName: "cityDistrict",
                type: {
                    name: "String"
                }
            },
            stateDistrict: {
                serializedName: "stateDistrict",
                type: {
                    name: "String"
                }
            },
            suburb: {
                serializedName: "suburb",
                type: {
                    name: "String"
                }
            },
            house: {
                serializedName: "house",
                type: {
                    name: "String"
                }
            },
            level: {
                serializedName: "level",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BuildDocumentModelRequest = {
    type: {
        name: "Composite",
        className: "BuildDocumentModelRequest",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            buildMode: {
                serializedName: "buildMode",
                required: true,
                type: {
                    name: "String"
                }
            },
            azureBlobSource: {
                serializedName: "azureBlobSource",
                type: {
                    name: "Composite",
                    className: "AzureBlobContentSource"
                }
            },
            azureBlobFileListSource: {
                serializedName: "azureBlobFileListSource",
                type: {
                    name: "Composite",
                    className: "AzureBlobFileListContentSource"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AzureBlobContentSource = {
    type: {
        name: "Composite",
        className: "AzureBlobContentSource",
        modelProperties: {
            containerUrl: {
                serializedName: "containerUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "prefix",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureBlobFileListContentSource = {
    type: {
        name: "Composite",
        className: "AzureBlobFileListContentSource",
        modelProperties: {
            containerUrl: {
                serializedName: "containerUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            fileList: {
                serializedName: "fileList",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComposeDocumentModelRequest = {
    type: {
        name: "Composite",
        className: "ComposeDocumentModelRequest",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            componentModels: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "componentModels",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComponentDocumentModelDetails"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ComponentDocumentModelDetails = {
    type: {
        name: "Composite",
        className: "ComponentDocumentModelDetails",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizeCopyRequest = {
    type: {
        name: "Composite",
        className: "AuthorizeCopyRequest",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CopyAuthorization = {
    type: {
        name: "Composite",
        className: "CopyAuthorization",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetResourceRegion: {
                serializedName: "targetResourceRegion",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetModelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "targetModelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetModelLocation: {
                serializedName: "targetModelLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                required: true,
                type: {
                    name: "String"
                }
            },
            expirationDateTime: {
                serializedName: "expirationDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GetOperationsResponse = {
    type: {
        name: "Composite",
        className: "GetOperationsResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationSummary = {
    type: {
        name: "Composite",
        className: "OperationSummary",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "failed",
                        "succeeded",
                        "canceled"
                    ]
                }
            },
            percentCompleted: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "percentCompleted",
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceLocation: {
                serializedName: "resourceLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const OperationDetails = {
    type: {
        name: "Composite",
        className: "OperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "failed",
                        "succeeded",
                        "canceled"
                    ]
                }
            },
            percentCompleted: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "percentCompleted",
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceLocation: {
                serializedName: "resourceLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const GetDocumentModelsResponse = {
    type: {
        name: "Composite",
        className: "GetDocumentModelsResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentModelSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentModelSummary = {
    type: {
        name: "Composite",
        className: "DocumentModelSummary",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            expiresOn: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DocumentModelDetails = {
    type: {
        name: "Composite",
        className: "DocumentModelDetails",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            expiresOn: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            docTypes: {
                serializedName: "docTypes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DocumentTypeDetails" }
                    }
                }
            }
        }
    }
};
const DocumentTypeDetails = {
    type: {
        name: "Composite",
        className: "DocumentTypeDetails",
        modelProperties: {
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            buildMode: {
                serializedName: "buildMode",
                type: {
                    name: "String"
                }
            },
            fieldSchema: {
                serializedName: "fieldSchema",
                required: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DocumentFieldSchema" }
                    }
                }
            },
            fieldConfidence: {
                serializedName: "fieldConfidence",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Number" },
                        constraints: { InclusiveMaximum: 1, InclusiveMinimum: 0 }
                    }
                }
            }
        }
    }
};
const DocumentFieldSchema = {
    type: {
        name: "Composite",
        className: "DocumentFieldSchema",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            example: {
                serializedName: "example",
                type: {
                    name: "String"
                }
            },
            items: {
                serializedName: "items",
                type: {
                    name: "Composite",
                    className: "DocumentFieldSchema"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DocumentFieldSchema" }
                    }
                }
            }
        }
    }
};
const BuildDocumentClassifierRequest = {
    type: {
        name: "Composite",
        className: "BuildDocumentClassifierRequest",
        modelProperties: {
            classifierId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "classifierId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            docTypes: {
                serializedName: "docTypes",
                required: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "ClassifierDocumentTypeDetails"
                        }
                    }
                }
            }
        }
    }
};
const ClassifierDocumentTypeDetails = {
    type: {
        name: "Composite",
        className: "ClassifierDocumentTypeDetails",
        modelProperties: {
            azureBlobSource: {
                serializedName: "azureBlobSource",
                type: {
                    name: "Composite",
                    className: "AzureBlobContentSource"
                }
            },
            azureBlobFileListSource: {
                serializedName: "azureBlobFileListSource",
                type: {
                    name: "Composite",
                    className: "AzureBlobFileListContentSource"
                }
            }
        }
    }
};
const GetDocumentClassifiersResponse = {
    type: {
        name: "Composite",
        className: "GetDocumentClassifiersResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentClassifierDetails"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentClassifierDetails = {
    type: {
        name: "Composite",
        className: "DocumentClassifierDetails",
        modelProperties: {
            classifierId: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$")
                },
                serializedName: "classifierId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            expiresOn: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            docTypes: {
                serializedName: "docTypes",
                required: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "ClassifierDocumentTypeDetails"
                        }
                    }
                }
            }
        }
    }
};
const ClassifyDocumentRequest = {
    type: {
        name: "Composite",
        className: "ClassifyDocumentRequest",
        modelProperties: {
            urlSource: {
                serializedName: "urlSource",
                type: {
                    name: "String"
                }
            },
            base64Source: {
                serializedName: "base64Source",
                type: {
                    name: "ByteArray"
                }
            }
        }
    }
};
const ResourceDetails = {
    type: {
        name: "Composite",
        className: "ResourceDetails",
        modelProperties: {
            customDocumentModels: {
                serializedName: "customDocumentModels",
                type: {
                    name: "Composite",
                    className: "CustomDocumentModelsDetails"
                }
            },
            customNeuralDocumentModelBuilds: {
                serializedName: "customNeuralDocumentModelBuilds",
                type: {
                    name: "Composite",
                    className: "QuotaDetails"
                }
            }
        }
    }
};
const CustomDocumentModelsDetails = {
    type: {
        name: "Composite",
        className: "CustomDocumentModelsDetails",
        modelProperties: {
            count: {
                serializedName: "count",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const QuotaDetails = {
    type: {
        name: "Composite",
        className: "QuotaDetails",
        modelProperties: {
            used: {
                serializedName: "used",
                required: true,
                type: {
                    name: "Number"
                }
            },
            quota: {
                serializedName: "quota",
                required: true,
                type: {
                    name: "Number"
                }
            },
            quotaResetOn: {
                serializedName: "quotaResetDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DocumentModelBuildOperationDetails = {
    serializedName: "documentModelBuild",
    type: {
        name: "Composite",
        className: "DocumentModelBuildOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentModelDetails"
                }
            } })
    }
};
const DocumentModelComposeOperationDetails = {
    serializedName: "documentModelCompose",
    type: {
        name: "Composite",
        className: "DocumentModelComposeOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentModelDetails"
                }
            } })
    }
};
const DocumentModelCopyToOperationDetails = {
    serializedName: "documentModelCopyTo",
    type: {
        name: "Composite",
        className: "DocumentModelCopyToOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentModelDetails"
                }
            } })
    }
};
const DocumentClassifierBuildOperationDetails = {
    serializedName: "documentClassifierBuild",
    type: {
        name: "Composite",
        className: "DocumentClassifierBuildOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentClassifierDetails"
                }
            } })
    }
};
const DocumentModelsAnalyzeDocumentHeaders = {
    type: {
        name: "Composite",
        className: "DocumentModelsAnalyzeDocumentHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentModelsBuildModelHeaders = {
    type: {
        name: "Composite",
        className: "DocumentModelsBuildModelHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentModelsComposeModelHeaders = {
    type: {
        name: "Composite",
        className: "DocumentModelsComposeModelHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentModelsCopyModelToHeaders = {
    type: {
        name: "Composite",
        className: "DocumentModelsCopyModelToHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentClassifiersBuildClassifierHeaders = {
    type: {
        name: "Composite",
        className: "DocumentClassifiersBuildClassifierHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentClassifiersClassifyDocumentHeaders = {
    type: {
        name: "Composite",
        className: "DocumentClassifiersClassifyDocumentHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    OperationDetails: OperationDetails,
    "OperationDetails.documentModelBuild": DocumentModelBuildOperationDetails,
    "OperationDetails.documentModelCompose": DocumentModelComposeOperationDetails,
    "OperationDetails.documentModelCopyTo": DocumentModelCopyToOperationDetails,
    "OperationDetails.documentClassifierBuild": DocumentClassifierBuildOperationDetails
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnalyzeDocumentRequest: AnalyzeDocumentRequest,
    ErrorResponse: ErrorResponse,
    ErrorModel: ErrorModel,
    InnerError: InnerError,
    AnalyzeResultOperation: AnalyzeResultOperation,
    AnalyzeResult: AnalyzeResult,
    DocumentPage: DocumentPage,
    DocumentSpan: DocumentSpan,
    DocumentWord: DocumentWord,
    DocumentSelectionMark: DocumentSelectionMark,
    DocumentLine: DocumentLine,
    DocumentBarcode: DocumentBarcode,
    DocumentFormula: DocumentFormula,
    DocumentParagraph: DocumentParagraph,
    BoundingRegion: BoundingRegion,
    DocumentTable: DocumentTable,
    DocumentTableCell: DocumentTableCell,
    DocumentKeyValuePair: DocumentKeyValuePair,
    DocumentKeyValueElement: DocumentKeyValueElement,
    DocumentStyle: DocumentStyle,
    DocumentLanguage: DocumentLanguage,
    Document: Document,
    DocumentField: DocumentField,
    CurrencyValue: CurrencyValue,
    AddressValue: AddressValue,
    BuildDocumentModelRequest: BuildDocumentModelRequest,
    AzureBlobContentSource: AzureBlobContentSource,
    AzureBlobFileListContentSource: AzureBlobFileListContentSource,
    ComposeDocumentModelRequest: ComposeDocumentModelRequest,
    ComponentDocumentModelDetails: ComponentDocumentModelDetails,
    AuthorizeCopyRequest: AuthorizeCopyRequest,
    CopyAuthorization: CopyAuthorization,
    GetOperationsResponse: GetOperationsResponse,
    OperationSummary: OperationSummary,
    OperationDetails: OperationDetails,
    GetDocumentModelsResponse: GetDocumentModelsResponse,
    DocumentModelSummary: DocumentModelSummary,
    DocumentModelDetails: DocumentModelDetails,
    DocumentTypeDetails: DocumentTypeDetails,
    DocumentFieldSchema: DocumentFieldSchema,
    BuildDocumentClassifierRequest: BuildDocumentClassifierRequest,
    ClassifierDocumentTypeDetails: ClassifierDocumentTypeDetails,
    GetDocumentClassifiersResponse: GetDocumentClassifiersResponse,
    DocumentClassifierDetails: DocumentClassifierDetails,
    ClassifyDocumentRequest: ClassifyDocumentRequest,
    ResourceDetails: ResourceDetails,
    CustomDocumentModelsDetails: CustomDocumentModelsDetails,
    QuotaDetails: QuotaDetails,
    DocumentModelBuildOperationDetails: DocumentModelBuildOperationDetails,
    DocumentModelComposeOperationDetails: DocumentModelComposeOperationDetails,
    DocumentModelCopyToOperationDetails: DocumentModelCopyToOperationDetails,
    DocumentClassifierBuildOperationDetails: DocumentClassifierBuildOperationDetails,
    DocumentModelsAnalyzeDocumentHeaders: DocumentModelsAnalyzeDocumentHeaders,
    DocumentModelsBuildModelHeaders: DocumentModelsBuildModelHeaders,
    DocumentModelsComposeModelHeaders: DocumentModelsComposeModelHeaders,
    DocumentModelsCopyModelToHeaders: DocumentModelsCopyModelToHeaders,
    DocumentClassifiersBuildClassifierHeaders: DocumentClassifiersBuildClassifierHeaders,
    DocumentClassifiersClassifyDocumentHeaders: DocumentClassifiersClassifyDocumentHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: "contentType",
    mapper: {
        serializedName: "Content-Type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: [
                "application/octet-stream",
                "application/pdf",
                "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                "image/bmp",
                "image/heif",
                "image/jpeg",
                "image/png",
                "image/tiff"
            ]
        }
    }
};
const analyzeRequest = {
    parameterPath: ["options", "analyzeRequest"],
    mapper: {
        serializedName: "analyzeRequest",
        type: {
            name: "Stream"
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: "contentType",
    mapper: {
        defaultValue: "text/html",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const analyzeRequest1 = {
    parameterPath: ["options", "analyzeRequest"],
    mapper: {
        serializedName: "analyzeRequest",
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType2 = {
    parameterPath: "contentType",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const analyzeRequest2 = {
    parameterPath: ["options", "analyzeRequest"],
    mapper: AnalyzeDocumentRequest
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const modelId = {
    parameterPath: "modelId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$"),
            MaxLength: 64
        },
        serializedName: "modelId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const pages = {
    parameterPath: ["options", "pages"],
    mapper: {
        constraints: {
            Pattern: new RegExp("^(\\d+(-\\d+)?)(,\\s*(\\d+(-\\d+)?))*$")
        },
        serializedName: "pages",
        type: {
            name: "String"
        }
    }
};
const locale = {
    parameterPath: ["options", "locale"],
    mapper: {
        serializedName: "locale",
        type: {
            name: "String"
        }
    }
};
const stringIndexType = {
    parameterPath: "stringIndexType",
    mapper: {
        serializedName: "stringIndexType",
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-07-31",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const features = {
    parameterPath: ["options", "features"],
    mapper: {
        serializedName: "features",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const resultId = {
    parameterPath: "resultId",
    mapper: {
        serializedName: "resultId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const contentType3 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const buildRequest = {
    parameterPath: "buildRequest",
    mapper: BuildDocumentModelRequest
};
const composeRequest = {
    parameterPath: "composeRequest",
    mapper: ComposeDocumentModelRequest
};
const authorizeCopyRequest = {
    parameterPath: "authorizeCopyRequest",
    mapper: AuthorizeCopyRequest
};
const copyToRequest = {
    parameterPath: "copyToRequest",
    mapper: CopyAuthorization
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"),
            MaxLength: 36
        },
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const buildRequest1 = {
    parameterPath: "buildRequest",
    mapper: BuildDocumentClassifierRequest
};
const classifierId = {
    parameterPath: "classifierId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}$"),
            MaxLength: 64
        },
        serializedName: "classifierId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const classifyRequest = {
    parameterPath: ["options", "classifyRequest"],
    mapper: {
        serializedName: "classifyRequest",
        type: {
            name: "Stream"
        }
    }
};
const classifyRequest1 = {
    parameterPath: ["options", "classifyRequest"],
    mapper: {
        serializedName: "classifyRequest",
        type: {
            name: "String"
        }
    }
};
const classifyRequest2 = {
    parameterPath: ["options", "classifyRequest"],
    mapper: ClassifyDocumentRequest
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns the innermost error that has a message field.
 *
 * @internal
 * @param error - the error to unwrap
 * @returns - the innermost populated error
 */
function unwrap(error) {
    if (error.innererror !== undefined && error.innererror.message !== undefined) {
        return unwrap(error.innererror);
    }
    return error;
}
/**
 * A class representing an Error from the Form Recognizer Service.
 *
 * For information about the error codes the service produces, refer to the service's error documentation:
 *
 * https://aka.ms/azsdk/formrecognizer/errors
 */
class FormRecognizerError extends Error {
    /**
     * Create a FormRecognizerError from a generated ErrorModel.
     * @internal
     * @hidden
     */
    constructor(formRecognizerError) {
        var _a;
        // TODO: We used to unwrap FR errors this way, but is it still necessary
        const e = unwrap(formRecognizerError);
        super(e.message);
        this.code = e.code;
        this.details = (_a = e.details) !== null && _a !== void 0 ? _a : [];
        this.target = e.target;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toBoundingPolygon(original) {
    const points = [];
    if (!original)
        return;
    if (original.length % 2 !== 0) {
        throw new Error("Unexpected number of points in the response, unable to translate as 2D points");
    }
    for (let i = 0; i < original.length; i += 2) {
        points.push({ x: original[i], y: original[i + 1] });
    }
    return points;
}
function toBoundingRegions(original) {
    return original === null || original === void 0 ? void 0 : original.map((region) => (Object.assign(Object.assign({}, region), { polygon: toBoundingPolygon(region.polygon) })));
}
function toDocumentTableFromGenerated(table) {
    return Object.assign(Object.assign({}, table), { boundingRegions: toBoundingRegions(table.boundingRegions), cells: table.cells.map((cell) => (Object.assign(Object.assign({}, cell), { boundingRegions: toBoundingRegions(cell.boundingRegions) }))) });
}
function toKeyValuePairFromGenerated(pair) {
    var _a;
    return Object.assign(Object.assign({}, pair), { key: Object.assign(Object.assign({}, pair.key), { boundingRegions: toBoundingRegions(pair.key.boundingRegions) }), value: pair.value
            ? Object.assign(Object.assign({}, pair.value), { boundingRegions: toBoundingRegions((_a = pair.value) === null || _a === void 0 ? void 0 : _a.boundingRegions) }) : undefined });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const APIM_SUBSCRIPTION_KEY_HEADER = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request using an `AzureKeyCredential` for Azure Form Recognizer
 * @internal
 */
function createFormRecognizerAzureKeyCredentialPolicy(credential) {
    return {
        name: "cognitiveServicesApimSubscriptionKeyCredentialPolicy",
        sendRequest(request, next) {
            request.headers.set(APIM_SUBSCRIPTION_KEY_HEADER, credential.key);
            return next(request);
        },
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link StringIndexType} that the service accepts. */
var KnownStringIndexType;
(function (KnownStringIndexType) {
    /** User-perceived display character, or grapheme cluster, as defined by Unicode 8.0.0. */
    KnownStringIndexType["TextElements"] = "textElements";
    /** Character unit represented by a single unicode code point.  Used by Python 3. */
    KnownStringIndexType["UnicodeCodePoint"] = "unicodeCodePoint";
    /** Character unit represented by a 16-bit Unicode code unit.  Used by JavaScript, Java, and .NET. */
    KnownStringIndexType["Utf16CodeUnit"] = "utf16CodeUnit";
})(KnownStringIndexType || (KnownStringIndexType = {}));
/** Known values of {@link DocumentAnalysisFeature} that the service accepts. */
var KnownDocumentAnalysisFeature;
(function (KnownDocumentAnalysisFeature) {
    /** Perform OCR at a higher resolution to handle documents with fine print. */
    KnownDocumentAnalysisFeature["OcrHighResolution"] = "ocrHighResolution";
    /** Enable the detection of the text content language. */
    KnownDocumentAnalysisFeature["Languages"] = "languages";
    /** Enable the detection of barcodes in the document. */
    KnownDocumentAnalysisFeature["Barcodes"] = "barcodes";
    /** Enable the detection of mathematical expressions in the document. */
    KnownDocumentAnalysisFeature["Formulas"] = "formulas";
    /** Enable the detection of general key value pairs (form fields) in the document. */
    KnownDocumentAnalysisFeature["KeyValuePairs"] = "keyValuePairs";
    /** Enable the recognition of various font styles. */
    KnownDocumentAnalysisFeature["StyleFont"] = "styleFont";
})(KnownDocumentAnalysisFeature || (KnownDocumentAnalysisFeature = {}));
/** Known values of {@link LengthUnit} that the service accepts. */
exports.KnownLengthUnit = void 0;
(function (KnownLengthUnit) {
    /** Length unit for image files. */
    KnownLengthUnit["Pixel"] = "pixel";
    /** Length unit for PDF files. */
    KnownLengthUnit["Inch"] = "inch";
})(exports.KnownLengthUnit || (exports.KnownLengthUnit = {}));
/** Known values of {@link SelectionMarkState} that the service accepts. */
exports.KnownSelectionMarkState = void 0;
(function (KnownSelectionMarkState) {
    /** The selection mark is selected, often indicated by a check  or cross X inside the selection mark. */
    KnownSelectionMarkState["Selected"] = "selected";
    /** The selection mark is not selected. */
    KnownSelectionMarkState["Unselected"] = "unselected";
})(exports.KnownSelectionMarkState || (exports.KnownSelectionMarkState = {}));
/** Known values of {@link DocumentBarcodeKind} that the service accepts. */
exports.KnownDocumentBarcodeKind = void 0;
(function (KnownDocumentBarcodeKind) {
    /** QR code, as defined in ISO/IEC 18004:2015. */
    KnownDocumentBarcodeKind["QRCode"] = "QRCode";
    /** PDF417, as defined in ISO 15438. */
    KnownDocumentBarcodeKind["PDF417"] = "PDF417";
    /** GS1 12-digit Universal Product Code. */
    KnownDocumentBarcodeKind["Upca"] = "UPCA";
    /** GS1 6-digit Universal Product Code. */
    KnownDocumentBarcodeKind["Upce"] = "UPCE";
    /** Code 39 barcode, as defined in ISO/IEC 16388:2007. */
    KnownDocumentBarcodeKind["Code39"] = "Code39";
    /** Code 128 barcode, as defined in ISO/IEC 15417:2007. */
    KnownDocumentBarcodeKind["Code128"] = "Code128";
    /** GS1 8-digit International Article Number (European Article Number). */
    KnownDocumentBarcodeKind["EAN8"] = "EAN8";
    /** GS1 13-digit International Article Number (European Article Number). */
    KnownDocumentBarcodeKind["EAN13"] = "EAN13";
    /** GS1 DataBar barcode. */
    KnownDocumentBarcodeKind["DataBar"] = "DataBar";
    /** Code 93 barcode, as defined in ANSI/AIM BC5-1995. */
    KnownDocumentBarcodeKind["Code93"] = "Code93";
    /** Codabar barcode, as defined in ANSI/AIM BC3-1995. */
    KnownDocumentBarcodeKind["Codabar"] = "Codabar";
    /** GS1 DataBar Expanded barcode. */
    KnownDocumentBarcodeKind["DataBarExpanded"] = "DataBarExpanded";
    /** Interleaved 2 of 5 barcode, as defined in ANSI/AIM BC2-1995. */
    KnownDocumentBarcodeKind["ITF"] = "ITF";
    /** Micro QR code, as defined in ISO/IEC 23941:2022. */
    KnownDocumentBarcodeKind["MicroQRCode"] = "MicroQRCode";
    /** Aztec code, as defined in ISO/IEC 24778:2008. */
    KnownDocumentBarcodeKind["Aztec"] = "Aztec";
    /** Data matrix code, as defined in ISO/IEC 16022:2006. */
    KnownDocumentBarcodeKind["DataMatrix"] = "DataMatrix";
    /** MaxiCode, as defined in ISO/IEC 16023:2000. */
    KnownDocumentBarcodeKind["MaxiCode"] = "MaxiCode";
})(exports.KnownDocumentBarcodeKind || (exports.KnownDocumentBarcodeKind = {}));
/** Known values of {@link DocumentFormulaKind} that the service accepts. */
exports.KnownDocumentFormulaKind = void 0;
(function (KnownDocumentFormulaKind) {
    /** A formula embedded within the content of a paragraph. */
    KnownDocumentFormulaKind["Inline"] = "inline";
    /** A formula in display mode that takes up an entire line. */
    KnownDocumentFormulaKind["Display"] = "display";
})(exports.KnownDocumentFormulaKind || (exports.KnownDocumentFormulaKind = {}));
/** Known values of {@link ParagraphRole} that the service accepts. */
exports.KnownParagraphRole = void 0;
(function (KnownParagraphRole) {
    /** Text near the top edge of the page. */
    KnownParagraphRole["PageHeader"] = "pageHeader";
    /** Text near the bottom edge of the page. */
    KnownParagraphRole["PageFooter"] = "pageFooter";
    /** Page number. */
    KnownParagraphRole["PageNumber"] = "pageNumber";
    /** Top-level title describing the entire document. */
    KnownParagraphRole["Title"] = "title";
    /** Sub heading describing a section of the document. */
    KnownParagraphRole["SectionHeading"] = "sectionHeading";
    /** A note usually placed after the main content on a page. */
    KnownParagraphRole["Footnote"] = "footnote";
    /** A block of formulas, often with shared alignment. */
    KnownParagraphRole["FormulaBlock"] = "formulaBlock";
})(exports.KnownParagraphRole || (exports.KnownParagraphRole = {}));
/** Known values of {@link DocumentTableCellKind} that the service accepts. */
exports.KnownDocumentTableCellKind = void 0;
(function (KnownDocumentTableCellKind) {
    /** Contains the main content/data. */
    KnownDocumentTableCellKind["Content"] = "content";
    /** Describes the content of the row. */
    KnownDocumentTableCellKind["RowHeader"] = "rowHeader";
    /** Describes the content of the column. */
    KnownDocumentTableCellKind["ColumnHeader"] = "columnHeader";
    /** Describes the row headers, usually located at the top left corner of a table. */
    KnownDocumentTableCellKind["StubHead"] = "stubHead";
    /** Describes the content in (parts of) the table. */
    KnownDocumentTableCellKind["Description"] = "description";
})(exports.KnownDocumentTableCellKind || (exports.KnownDocumentTableCellKind = {}));
/** Known values of {@link FontStyle} that the service accepts. */
exports.KnownFontStyle = void 0;
(function (KnownFontStyle) {
    /** Characters are represented normally. */
    KnownFontStyle["Normal"] = "normal";
    /** Characters are visually slanted to the right. */
    KnownFontStyle["Italic"] = "italic";
})(exports.KnownFontStyle || (exports.KnownFontStyle = {}));
/** Known values of {@link FontWeight} that the service accepts. */
exports.KnownFontWeight = void 0;
(function (KnownFontWeight) {
    /** Characters are represented normally. */
    KnownFontWeight["Normal"] = "normal";
    /** Characters are represented with thicker strokes. */
    KnownFontWeight["Bold"] = "bold";
})(exports.KnownFontWeight || (exports.KnownFontWeight = {}));
/** Known values of {@link DocumentFieldType} that the service accepts. */
exports.KnownDocumentFieldType = void 0;
(function (KnownDocumentFieldType) {
    /** Plain text. */
    KnownDocumentFieldType["String"] = "string";
    /** Date, normalized to ISO 8601 (YYYY-MM-DD) format. */
    KnownDocumentFieldType["Date"] = "date";
    /** Time, normalized to ISO 8601 (hh:mm:ss) format. */
    KnownDocumentFieldType["Time"] = "time";
    /** Phone number, normalized to E.164 (+{CountryCode}{SubscriberNumber}) format. */
    KnownDocumentFieldType["PhoneNumber"] = "phoneNumber";
    /** Floating point number, normalized to double precision floating point. */
    KnownDocumentFieldType["Number"] = "number";
    /** Integer number, normalized to 64-bit signed integer. */
    KnownDocumentFieldType["Integer"] = "integer";
    /** Is field selected? */
    KnownDocumentFieldType["SelectionMark"] = "selectionMark";
    /** Country/region, normalized to ISO 3166-1 alpha-3 format (ex. USA). */
    KnownDocumentFieldType["CountryRegion"] = "countryRegion";
    /** Is signature present? */
    KnownDocumentFieldType["Signature"] = "signature";
    /** List of subfields of the same type. */
    KnownDocumentFieldType["Array"] = "array";
    /** Named list of subfields of potentially different types. */
    KnownDocumentFieldType["Object"] = "object";
    /** Currency amount with optional currency symbol and unit. */
    KnownDocumentFieldType["Currency"] = "currency";
    /** Parsed address. */
    KnownDocumentFieldType["Address"] = "address";
    /** Boolean value, normalized to true or false. */
    KnownDocumentFieldType["Boolean"] = "boolean";
})(exports.KnownDocumentFieldType || (exports.KnownDocumentFieldType = {}));
/** Known values of {@link DocumentSignatureType} that the service accepts. */
exports.KnownDocumentSignatureType = void 0;
(function (KnownDocumentSignatureType) {
    /** A signature is detected. */
    KnownDocumentSignatureType["Signed"] = "signed";
    /** No signatures are detected. */
    KnownDocumentSignatureType["Unsigned"] = "unsigned";
})(exports.KnownDocumentSignatureType || (exports.KnownDocumentSignatureType = {}));
/** Known values of {@link DocumentBuildMode} that the service accepts. */
exports.KnownDocumentBuildMode = void 0;
(function (KnownDocumentBuildMode) {
    /** Target documents with similar visual templates. */
    KnownDocumentBuildMode["Template"] = "template";
    /** Support documents with diverse visual templates. */
    KnownDocumentBuildMode["Neural"] = "neural";
})(exports.KnownDocumentBuildMode || (exports.KnownDocumentBuildMode = {}));
/** Known values of {@link OperationKind} that the service accepts. */
exports.KnownOperationKind = void 0;
(function (KnownOperationKind) {
    /** Build a new custom document model. */
    KnownOperationKind["DocumentModelBuild"] = "documentModelBuild";
    /** Compose a new custom document model from existing models. */
    KnownOperationKind["DocumentModelCompose"] = "documentModelCompose";
    /** Copy an existing document model to potentially a different resource, region, or subscription. */
    KnownOperationKind["DocumentModelCopyTo"] = "documentModelCopyTo";
    /** Build a new custom classifier model. */
    KnownOperationKind["DocumentClassifierBuild"] = "documentClassifierBuild";
})(exports.KnownOperationKind || (exports.KnownOperationKind = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DocumentModels operations. */
class DocumentModelsImpl {
    /**
     * Initialize a new instance of the class DocumentModels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all document models
     * @param options The options parameters.
     */
    listModels(options) {
        const iter = this.listModelsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listModelsPagingPage(options);
            }
        };
    }
    listModelsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listModelsPagingPage_1() {
            let result = yield tslib.__await(this._listModels(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listModelsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listModelsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listModelsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listModelsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Analyzes document with document model.
     * @param args Includes all the parameters for this operation.
     */
    analyzeDocument(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[1] === "application/octet-stream" ||
            args[1] === "application/pdf" ||
            args[1] ===
                "application/vnd.openxmlformats-officedocument.presentationml.presentation" ||
            args[1] ===
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" ||
            args[1] ===
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
            args[1] === "image/bmp" ||
            args[1] === "image/heif" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = analyzeDocument$binaryOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else if (args[1] === "text/html") {
            operationSpec = analyzeDocument$textOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else if (args[1] === "application/json") {
            operationSpec = analyzeDocument$jsonOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Gets the result of document analysis.
     * @param modelId Unique document model name.
     * @param resultId Analyze operation result ID.
     * @param options The options parameters.
     */
    getAnalyzeResult(modelId, resultId, options) {
        return this.client.sendOperationRequest({ modelId, resultId, options }, getAnalyzeResultOperationSpec);
    }
    /**
     * Builds a custom document analysis model.
     * @param buildRequest Building request parameters.
     * @param options The options parameters.
     */
    buildModel(buildRequest, options) {
        return this.client.sendOperationRequest({ buildRequest, options }, buildModelOperationSpec);
    }
    /**
     * Creates a new document model from document types of existing document models.
     * @param composeRequest Compose request parameters.
     * @param options The options parameters.
     */
    composeModel(composeRequest, options) {
        return this.client.sendOperationRequest({ composeRequest, options }, composeModelOperationSpec);
    }
    /**
     * Generates authorization to copy a document model to this location with specified modelId and
     * optional description.
     * @param authorizeCopyRequest Authorize copy request parameters.
     * @param options The options parameters.
     */
    authorizeModelCopy(authorizeCopyRequest, options) {
        return this.client.sendOperationRequest({ authorizeCopyRequest, options }, authorizeModelCopyOperationSpec);
    }
    /**
     * Copies document model to the target resource, region, and modelId.
     * @param modelId Unique document model name.
     * @param copyToRequest Copy to request parameters.
     * @param options The options parameters.
     */
    copyModelTo(modelId, copyToRequest, options) {
        return this.client.sendOperationRequest({ modelId, copyToRequest, options }, copyModelToOperationSpec);
    }
    /**
     * List all document models
     * @param options The options parameters.
     */
    _listModels(options) {
        return this.client.sendOperationRequest({ options }, listModelsOperationSpec);
    }
    /**
     * Gets detailed document model information.
     * @param modelId Unique document model name.
     * @param options The options parameters.
     */
    getModel(modelId, options) {
        return this.client.sendOperationRequest({ modelId, options }, getModelOperationSpec);
    }
    /**
     * Deletes document model.
     * @param modelId Unique document model name.
     * @param options The options parameters.
     */
    deleteModel(modelId, options) {
        return this.client.sendOperationRequest({ modelId, options }, deleteModelOperationSpec);
    }
    /**
     * ListModelsNext
     * @param nextLink The nextLink from the previous successful call to the ListModels method.
     * @param options The options parameters.
     */
    _listModelsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listModelsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const analyzeDocument$binaryOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentModelsAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: analyzeRequest,
    queryParameters: [
        pages,
        locale,
        stringIndexType,
        apiVersion,
        features
    ],
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType, accept],
    mediaType: "binary",
    serializer: serializer$2
};
const analyzeDocument$textOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentModelsAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: analyzeRequest1,
    queryParameters: [
        pages,
        locale,
        stringIndexType,
        apiVersion,
        features
    ],
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType1, accept1],
    mediaType: "text",
    serializer: serializer$2
};
const analyzeDocument$jsonOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentModelsAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: analyzeRequest2,
    queryParameters: [
        pages,
        locale,
        stringIndexType,
        apiVersion,
        features
    ],
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType2, accept2],
    mediaType: "json",
    serializer: serializer$2
};
const getAnalyzeResultOperationSpec = {
    path: "/documentModels/{modelId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeResultOperation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId, resultId],
    headerParameters: [accept2],
    serializer: serializer$2
};
const buildModelOperationSpec = {
    path: "/documentModels:build",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentModelsBuildModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: buildRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2, contentType3],
    mediaType: "json",
    serializer: serializer$2
};
const composeModelOperationSpec = {
    path: "/documentModels:compose",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentModelsComposeModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: composeRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2, contentType3],
    mediaType: "json",
    serializer: serializer$2
};
const authorizeModelCopyOperationSpec = {
    path: "/documentModels:authorizeCopy",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CopyAuthorization
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: authorizeCopyRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2, contentType3],
    mediaType: "json",
    serializer: serializer$2
};
const copyModelToOperationSpec = {
    path: "/documentModels/{modelId}:copyTo",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentModelsCopyModelToHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: copyToRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept2, contentType3],
    mediaType: "json",
    serializer: serializer$2
};
const listModelsOperationSpec = {
    path: "/documentModels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetDocumentModelsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2],
    serializer: serializer$2
};
const getModelOperationSpec = {
    path: "/documentModels/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DocumentModelDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept2],
    serializer: serializer$2
};
const deleteModelOperationSpec = {
    path: "/documentModels/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept2],
    serializer: serializer$2
};
const listModelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetDocumentModelsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept2],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Miscellaneous operations. */
class MiscellaneousImpl {
    /**
     * Initialize a new instance of the class Miscellaneous class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all operations.
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOperationsPagingPage(options);
            }
        };
    }
    listOperationsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result = yield tslib.__await(this._listOperations(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOperationsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all operations.
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec);
    }
    /**
     * Gets operation info.
     * @param operationId Unique operation ID.
     * @param options The options parameters.
     */
    getOperation(operationId, options) {
        return this.client.sendOperationRequest({ operationId, options }, getOperationOperationSpec);
    }
    /**
     * Return information about the current resource.
     * @param options The options parameters.
     */
    getResourceInfo(options) {
        return this.client.sendOperationRequest({ options }, getResourceInfoOperationSpec);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationsOperationSpec = {
    path: "/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetOperationsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2],
    serializer: serializer$1
};
const getOperationOperationSpec = {
    path: "/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, operationId],
    headerParameters: [accept2],
    serializer: serializer$1
};
const getResourceInfoOperationSpec = {
    path: "/info",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2],
    serializer: serializer$1
};
const listOperationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetOperationsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept2],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DocumentClassifiers operations. */
class DocumentClassifiersImpl {
    /**
     * Initialize a new instance of the class DocumentClassifiers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all document classifiers.
     * @param options The options parameters.
     */
    listClassifiers(options) {
        const iter = this.listClassifiersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listClassifiersPagingPage(options);
            }
        };
    }
    listClassifiersPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listClassifiersPagingPage_1() {
            let result = yield tslib.__await(this._listClassifiers(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listClassifiersNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listClassifiersPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listClassifiersPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listClassifiersPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Builds a custom document classifier.
     * @param buildRequest Building request parameters.
     * @param options The options parameters.
     */
    buildClassifier(buildRequest, options) {
        return this.client.sendOperationRequest({ buildRequest, options }, buildClassifierOperationSpec);
    }
    /**
     * List all document classifiers.
     * @param options The options parameters.
     */
    _listClassifiers(options) {
        return this.client.sendOperationRequest({ options }, listClassifiersOperationSpec);
    }
    /**
     * Gets detailed document classifier information.
     * @param classifierId Unique document classifier name.
     * @param options The options parameters.
     */
    getClassifier(classifierId, options) {
        return this.client.sendOperationRequest({ classifierId, options }, getClassifierOperationSpec);
    }
    /**
     * Deletes document classifier.
     * @param classifierId Unique document classifier name.
     * @param options The options parameters.
     */
    deleteClassifier(classifierId, options) {
        return this.client.sendOperationRequest({ classifierId, options }, deleteClassifierOperationSpec);
    }
    /**
     * Classifies document with document classifier.
     * @param args Includes all the parameters for this operation.
     */
    classifyDocument(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[1] === "application/octet-stream" ||
            args[1] === "application/pdf" ||
            args[1] ===
                "application/vnd.openxmlformats-officedocument.presentationml.presentation" ||
            args[1] ===
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" ||
            args[1] ===
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
            args[1] === "image/bmp" ||
            args[1] === "image/heif" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = classifyDocument$binaryOperationSpec;
            operationArguments = {
                classifierId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else if (args[1] === "text/html") {
            operationSpec = classifyDocument$textOperationSpec;
            operationArguments = {
                classifierId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else if (args[1] === "application/json") {
            operationSpec = classifyDocument$jsonOperationSpec;
            operationArguments = {
                classifierId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Gets the result of document classifier.
     * @param classifierId Unique document classifier name.
     * @param resultId Analyze operation result ID.
     * @param options The options parameters.
     */
    getClassifyResult(classifierId, resultId, options) {
        return this.client.sendOperationRequest({ classifierId, resultId, options }, getClassifyResultOperationSpec);
    }
    /**
     * ListClassifiersNext
     * @param nextLink The nextLink from the previous successful call to the ListClassifiers method.
     * @param options The options parameters.
     */
    _listClassifiersNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listClassifiersNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const buildClassifierOperationSpec = {
    path: "/documentClassifiers:build",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentClassifiersBuildClassifierHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: buildRequest1,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2, contentType3],
    mediaType: "json",
    serializer
};
const listClassifiersOperationSpec = {
    path: "/documentClassifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetDocumentClassifiersResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept2],
    serializer
};
const getClassifierOperationSpec = {
    path: "/documentClassifiers/{classifierId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DocumentClassifierDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, classifierId],
    headerParameters: [accept2],
    serializer
};
const deleteClassifierOperationSpec = {
    path: "/documentClassifiers/{classifierId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, classifierId],
    headerParameters: [accept2],
    serializer
};
const classifyDocument$binaryOperationSpec = {
    path: "/documentClassifiers/{classifierId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentClassifiersClassifyDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: classifyRequest,
    queryParameters: [stringIndexType, apiVersion],
    urlParameters: [endpoint, classifierId],
    headerParameters: [contentType, accept],
    mediaType: "binary",
    serializer
};
const classifyDocument$textOperationSpec = {
    path: "/documentClassifiers/{classifierId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentClassifiersClassifyDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: classifyRequest1,
    queryParameters: [stringIndexType, apiVersion],
    urlParameters: [endpoint, classifierId],
    headerParameters: [contentType1, accept1],
    mediaType: "text",
    serializer
};
const classifyDocument$jsonOperationSpec = {
    path: "/documentClassifiers/{classifierId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: DocumentClassifiersClassifyDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: classifyRequest2,
    queryParameters: [stringIndexType, apiVersion],
    urlParameters: [endpoint, classifierId],
    headerParameters: [contentType2, accept2],
    mediaType: "json",
    serializer
};
const getClassifyResultOperationSpec = {
    path: "/documentClassifiers/{classifierId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeResultOperation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        resultId,
        classifierId
    ],
    headerParameters: [accept2],
    serializer
};
const listClassifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetDocumentClassifiersResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept2],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class GeneratedClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for
     *                 example: https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-form-recognizer/5.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}/formrecognizer" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2023-07-31";
        this.documentModels = new DocumentModelsImpl(this);
        this.miscellaneous = new MiscellaneousImpl(this);
        this.documentClassifiers = new DocumentClassifiersImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Supported values of StringIndexType.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const StringIndexType = {
    /**
     * UTF-16 code units
     */
    Utf16CodeUnit: "utf16CodeUnit",
    /**
     * Unicode code points
     */
    UnicodeCodePoint: "unicodeCodePoint",
};
/**
 * Default settings for Form Recognizer clients.
 *
 * @internal
 */
const DEFAULT_GENERATED_CLIENT_OPTIONS = {
    stringIndexType: StringIndexType.Utf16CodeUnit,
};

// Copyright (c) Microsoft Corporation.
// This is used for URL request processing.
const SERIALIZER = coreClient.createSerializer(Mappers, false);
/**
 * Type-strong uncapitalization.
 * @internal
 */
const uncapitalize = (s) => (s.substring(0, 1).toLowerCase() + s.substring(1));
/**
 * Type-strong capitalization
 * @internal
 */
const capitalize = (s) => (s.substring(0, 1).toUpperCase() + s.substring(1));
/**
 * Tests if a string looks like it begins with an acronym, i.e. it starts with two capital letters.
 * @internal
 */
const isAcronymic = (s) => {
    return /^[A-Z][A-Z]/.test(s);
};
/**
 * Map an optional value through a function
 * @internal
 */
const maybemap = (value, f) => value === undefined ? undefined : f(value);
/**
 * Create a GeneratedClient.
 * @internal
 */
function makeServiceClient(endpoint, credential, options) {
    const client = new GeneratedClient(endpoint === null || endpoint === void 0 ? void 0 : endpoint.replace(/\/$/, ""), Object.assign(Object.assign(Object.assign({}, DEFAULT_GENERATED_CLIENT_OPTIONS), options), { apiVersion: FORM_RECOGNIZER_API_VERSION }));
    const authPolicy = coreAuth.isTokenCredential(credential)
        ? coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential,
            scopes: DEFAULT_COGNITIVE_SCOPE,
        })
        : createFormRecognizerAzureKeyCredentialPolicy(credential);
    client.pipeline.addPolicy(authPolicy);
    return client;
}

// Copyright (c) Microsoft Corporation.
/**
 * Convert a record of generated fields to a record of strongly-typed fields.
 * @internal
 * @param fields - a map of field names to generated field values
 * @returns - an object with the same keys, where all values have been mapped to DocumentFields
 */
function toAnalyzedDocumentFieldsFromGenerated(fields) {
    return Object.entries(fields !== null && fields !== void 0 ? fields : {}).reduce((transformedFields, [name, value]) => {
        transformedFields[name] = toDocumentField(value);
        return transformedFields;
    }, {});
}
/**
 * Convert a generated document field into a strong TypeScriptified document field.
 * @internal
 */
function toDocumentField(field) {
    const kind = field.type;
    const value = (() => {
        var _a, _b;
        switch (kind) {
            // Almost all value kinds are represented as simple elemental values
            case "string":
            case "date":
            case "time":
            case "phoneNumber":
            case "number":
            case "boolean":
            case "integer":
            case "selectionMark":
            case "countryRegion":
            case "signature":
            case "currency":
            case "address":
                return {
                    value: field[("value" + capitalize(kind))],
                };
            case "array":
                return { values: (_a = field.valueArray) === null || _a === void 0 ? void 0 : _a.map((v) => { var _a; return (_a = toDocumentField(v)) !== null && _a !== void 0 ? _a : []; }) };
            case "object":
                return { properties: toAnalyzedDocumentFieldsFromGenerated((_b = field.valueObject) !== null && _b !== void 0 ? _b : {}) };
            default:
                // Exhaustiveness check
                // eslint-disable-next-line no-case-declarations
                const __exhaust = kind;
                throw new Error(`Unrecognized DocumentField type: ${__exhaust}`);
        }
    })();
    return Object.assign(Object.assign({ kind }, value), { boundingRegions: toBoundingRegions(field.boundingRegions), content: field.content, spans: field.spans, confidence: field.confidence });
}

// Copyright (c) Microsoft Corporation.
/**
 * Transform a REST-level Document response object into the more strongly-typed AnalyzedDocument.
 *
 * @internal
 * @param document - a REST-level document response object
 * @returns an AnalyzedDocument (which has had its fields mapped to stronger DocumentField types)
 */
function toAnalyzedDocumentFromGenerated(document) {
    var _a;
    return Object.assign(Object.assign({}, document), { boundingRegions: toBoundingRegions(document.boundingRegions), fields: toAnalyzedDocumentFieldsFromGenerated((_a = document.fields) !== null && _a !== void 0 ? _a : {}) });
}
/**
 * Tests if one span contains another, by testing that the outer span starts before or at the same character as the
 * inner span, and that the end position of the outer span is greater than or equal to the end position of the inner
 * span.
 *
 * @internal
 * @param outer - the outer (potentially containing) span
 * @param inner - the span to test if `outer` contains
 * @returns true if `inner` is contained inside of `outer`.
 */
function contains(outer, inner) {
    return outer.offset <= inner.offset && outer.offset + outer.length >= inner.offset + inner.length;
}
/**
 * Make an empty generator. This might seem silly, but it's useful for satisfying invariants.
 */
function* empty() {
    /* intentionally empty */
}
/**
 * Produces an iterator of the given items starting from the given index.
 *
 * @param items - the items to iterate over
 * @param idx - the index of the first item to begin iterating from
 */
function* iterFrom(items, idx) {
    let i = idx;
    while (i < items.length) {
        yield items[i++];
    }
}
function toDocumentLineFromGenerated(generated, page) {
    generated.words = () => {
        var _a, _b;
        return fastGetChildren(iterFrom(generated.spans, 0), (_b = (_a = page.words) === null || _a === void 0 ? void 0 : _a.map((word) => {
            return Object.assign(Object.assign({}, word), { polygon: toBoundingPolygon(word.polygon) });
        })) !== null && _b !== void 0 ? _b : []);
    };
    generated.polygon = toBoundingPolygon(generated.polygon);
    Object.defineProperty(generated, "words", {
        enumerable: false,
    });
    return generated;
}
function toDocumentPageFromGenerated(generated) {
    var _a, _b, _c, _d, _e;
    return Object.assign(Object.assign({}, generated), { lines: (_a = generated.lines) === null || _a === void 0 ? void 0 : _a.map((line) => toDocumentLineFromGenerated(line, generated)), selectionMarks: (_b = generated.selectionMarks) === null || _b === void 0 ? void 0 : _b.map((mark) => (Object.assign(Object.assign({}, mark), { polygon: toBoundingPolygon(mark.polygon) }))), words: (_c = generated.words) === null || _c === void 0 ? void 0 : _c.map((word) => (Object.assign(Object.assign({}, word), { polygon: toBoundingPolygon(word.polygon) }))), barcodes: (_d = generated.barcodes) === null || _d === void 0 ? void 0 : _d.map((barcode) => (Object.assign(Object.assign({}, barcode), { polygon: toBoundingPolygon(barcode.polygon) }))), formulas: (_e = generated.formulas) === null || _e === void 0 ? void 0 : _e.map((formula) => (Object.assign(Object.assign({}, formula), { polygon: toBoundingPolygon(formula.polygon) }))) });
}
/**
 * Binary search through an array of items to find the first item that could possibly be contained by the given span,
 * then return an iterator beginning from that item.
 *
 * This allows a program to quickly find the first relevant item in the array for consideration when testing for span
 * inclusion.
 *
 * @internal
 * @param span - the span to use when testing each individual item
 * @param items - an array of items to binary search through
 * @returns an iterator beginning from the item identified by the search
 */
function iteratorFromFirstMatchBinarySearch(span, items) {
    let idx = Math.floor(items.length / 2);
    let prevIdx = idx;
    let min = 0;
    let max = items.length;
    const found = () => { var _a, _b, _c; 
    // The item is found if it starts after the current span and the item before it does not. That means it is the first
    // item in the array that could be a child if the spans are sorted.
    return items[idx].span.offset >= span.offset && ((_c = (_b = (_a = items[idx - 1]) === null || _a === void 0 ? void 0 : _a.span) === null || _b === void 0 ? void 0 : _b.offset) !== null && _c !== void 0 ? _c : -1) < span.offset; };
    // Binary search to find the first element that could be a child
    do {
        if (found()) {
            return iterFrom(items, idx);
        }
        else if (span.offset > items[idx].span.offset) {
            min = prevIdx = idx;
            idx = Math.floor(idx + (max - idx) / 2);
        }
        else {
            max = prevIdx = idx;
            idx = Math.floor(idx - (idx - min) / 2);
        }
    } while (idx !== prevIdx);
    // This might seem weird, but it's a simple way to make the types a little more elegant.
    return empty();
}
/**
 * This fast algorithm tests the elements of `childArray` for inclusion in any of the given `spans`, assuming that both
 * the spans and child items are sorted.
 *
 * INVARIANT: the items in both the `spans` iterator and `childrenArray` MUST BE SORTED INCREASING by span _offset_.
 *
 * @internal
 * @param spans - the spans that contain the child elements
 * @param childrenArray - an array of child items (items that have spans) to test for inclusion in the spans
 * @returns - an IterableIterator of child items that are included in any span in the `spans` iterator
 */
function* fastGetChildren(spans, childrenArray) {
    let curSpan = spans.next();
    // Need to exit early if there are no spans.
    if (curSpan.done) {
        return;
    }
    const children = iteratorFromFirstMatchBinarySearch(curSpan.value, childrenArray);
    let curChild = children.next();
    while (!(curChild.done || curSpan.done)) {
        if (contains(curSpan.value, curChild.value.span)) {
            // The span is contained, so yield the current child and advance it.
            yield curChild.value;
            curChild = children.next();
        }
        else if (curSpan.value.offset + curSpan.value.length < curChild.value.span.offset) {
            // The current span ends before the next potential child starts, so advance the span
            curSpan = spans.next();
        }
        else {
            // The current child was not contained in the current span, so advance to the next child.
            curChild = children.next();
        }
    }
}
/**
 * Convert a generated AnalyzeResult into a convenience layer AnalyzeResult.
 * @internal
 */
function toAnalyzeResultFromGenerated(result) {
    var _a, _b, _c, _d;
    return {
        apiVersion: result.apiVersion,
        modelId: result.modelId,
        content: result.content,
        pages: result.pages.map((page) => toDocumentPageFromGenerated(page)),
        tables: (_a = result.tables) === null || _a === void 0 ? void 0 : _a.map((table) => toDocumentTableFromGenerated(table)),
        keyValuePairs: (_b = result.keyValuePairs) === null || _b === void 0 ? void 0 : _b.map((pair) => toKeyValuePairFromGenerated(pair)),
        languages: result.languages,
        styles: result.styles,
        paragraphs: (_c = result.paragraphs) === null || _c === void 0 ? void 0 : _c.map((para) => (Object.assign(Object.assign({}, para), { boundingRegions: toBoundingRegions(para.boundingRegions) }))),
        documents: (_d = result.documents) === null || _d === void 0 ? void 0 : _d.map(toAnalyzedDocumentFromGenerated),
    };
}
/**
 * Converts an AnalyzeResultOperation (LRO response) to a DocumentAnalysisPollOperationState
 * @internal
 */
function toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, response) {
    return {
        status: response.status,
        modelId: modelId,
        lastUpdatedOn: response.lastUpdatedOn,
        createdOn: response.createdOn,
        operationLocation,
        result: response.analyzeResult && definition.transformResult(response.analyzeResult),
        error: response.error && new FormRecognizerError(response.error),
        isCancelled: false,
        isStarted: response.status !== "notStarted",
        isCompleted: response.status === "succeeded",
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * A promise that delays resolution until a certain amount of time (in milliseconds) has passed, with facilities for
 * robust cancellation.
 *
 * ### Example:
 *
 * ```javascript
 * let toCancel;
 *
 * // Wait 20 seconds, and optionally allow the function to be cancelled.
 * await delayMs(20000, (cancel) => { toCancel = cancel });
 *
 * // ... if `toCancel` is called before the 20 second timer expires, then the delayMs promise will reject.
 * ```
 *
 * @internal
 * @param ms - the number of milliseconds to wait before resolving
 * @param cb - a callback that can provide the caller with a cancellation function
 */
function delayMs(ms, abortSignal) {
    let aborted = false;
    let toReject;
    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", () => {
        aborted = true;
        toReject === null || toReject === void 0 ? void 0 : toReject(new abortController.AbortError("The operation was aborted."));
    });
    return Object.assign(new Promise((resolve, reject) => {
        let token;
        toReject = (e) => {
            maybemap(token, clearTimeout);
            reject(e);
        };
        // In the rare case that the operation is _already_ aborted, we will reject instantly. This could happen, for
        // example, if the user calls the cancellation function immediately without yielding execution.
        if (aborted) {
            toReject(new Error("The operation was cancelled prematurely."));
        }
        else {
            token = setTimeout(resolve, ms);
        }
    }), {
        cancel: () => {
            aborted = true;
            toReject === null || toReject === void 0 ? void 0 : toReject(new Error("The operation was cancelled."));
        },
    });
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_POLLING_INTERVAL = 5000;
/**
 * Uniform poller implementation, creates a poller based on a PollerSpec.
 *
 * @internal
 */
async function lro(spec, pollingInterval, initAbortSignal) {
    let serverDrivenDelay;
    const initContext = {
        abortSignal: initAbortSignal,
        updateDelay: (interval) => {
            serverDrivenDelay = interval;
        },
    };
    if (initAbortSignal === null || initAbortSignal === void 0 ? void 0 : initAbortSignal.aborted) {
        throw new abortController.AbortError("The operation was aborted.");
    }
    let state = await spec.init(initContext);
    // Job handling. If `job` is defined, then there is an active `pollUntilDone` call on this poller.
    // Call `cancelJob` to interrupt the polling loop (awaiters will throw).
    let job;
    let cancelJob;
    const handlers = new Map();
    const handleProgressEvents = async () => handlers.forEach((h) => h(state));
    const self = {
        onProgress: (callback) => {
            const s = Symbol();
            handlers.set(s, callback);
            return () => handlers.delete(s);
        },
        stopPolling: () => cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob(),
        poll: async (options) => {
            state = await spec.poll({
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                updateDelay: (interval) => {
                    serverDrivenDelay = interval;
                },
            }, state);
            handleProgressEvents();
        },
        pollUntilDone: (options) => (job !== null && job !== void 0 ? job : (job = (async () => {
            // Technically, the poller could complete during initialization
            if (!self.isDone()) {
                // Poll once to get the ball rolling, this avoids a delay if the operation completes immediately
                await self.poll(options);
                while (!self.isDone()) {
                    const finalPollingInterval = Math.max(serverDrivenDelay !== null && serverDrivenDelay !== void 0 ? serverDrivenDelay : 0, pollingInterval !== null && pollingInterval !== void 0 ? pollingInterval : DEFAULT_POLLING_INTERVAL);
                    const delay = delayMs(finalPollingInterval, options === null || options === void 0 ? void 0 : options.abortSignal);
                    cancelJob = delay.cancel;
                    await delay.then(() => self.poll());
                }
            }
            const result = self.getResult();
            // The state says it's done, so we know we are in either a success case, an error case, or an _internal_ error.
            if (result !== undefined)
                return result;
            else if (state.error !== undefined)
                throw state.error;
            // Unreachable
            else {
                throw new Error(`Internal Client Error: analysis poller completed without success or error: ${state}`);
            }
        })().finally(() => {
            job = undefined;
        }))),
        // The poller is stopped if there is no job running
        isStopped: () => !!job,
        // The operation is complete if either a result or error is produced
        isDone: () => !!state.result || !!state.error,
        // In FR, all operations run to completion
        cancelOperation() {
            throw new Error("The Azure Form Recognizer service does not support operation cancellation.");
        },
        getOperationState: () => state,
        getResult: () => state.result,
        toString: () => spec.serialize(state),
    };
    return self;
}

// Copyright (c) Microsoft Corporation.
/**
 * A client for interacting with the Form Recognizer service's analysis features.
 *
 * ### Examples:
 *
 * The Form Recognizer service and clients support two means of authentication:
 *
 * #### Azure Active Directory
 *
 * ```javascript
 * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```javascript
 * import { DocumentAnalysisClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 */
class DocumentAnalysisClient {
    constructor(endpoint, credential, options = {}) {
        this._restClient = makeServiceClient(endpoint, credential, options);
        this._tracing = coreTracing.createTracingClient({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    async beginAnalyzeDocument(model, document, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocument", options, 
        // In the first version of the SDK, the document input was treated as a URL if it was a string, and we preserve
        // this behavior to avoid introducing a breaking change.
        this.analyze.bind(this, model, typeof document === "string" ? source("url", document) : source("body", document)));
    }
    async beginAnalyzeDocumentFromUrl(model, documentUrl, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocumentFromUrl", options, this.analyze.bind(this, model, source("url", documentUrl)));
    }
    /**
     * A helper method for running analysis polymorphically.
     *
     * @param model - the model ID or DocumentModel to use for analysis
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns - an analysis poller
     */
    analyze(model, input, options) {
        const { modelId: initialModelId, apiVersion: requestApiVersion, transformResult, } = typeof model === "string"
            ? { modelId: model, apiVersion: undefined, transformResult: (v) => v }
            : model;
        if (requestApiVersion && requestApiVersion !== FORM_RECOGNIZER_API_VERSION) {
            throw new Error([
                `API Version mismatch: the provided model wants version: ${requestApiVersion},`,
                `but the client is using ${FORM_RECOGNIZER_API_VERSION}.`,
                "The API version of the model must match the client's API version.",
            ].join(" "));
        }
        return this.createUnifiedPoller((abortSignal) => {
            const [contentType, analyzeRequest] = toAnalyzeRequest(input);
            return this._restClient.documentModels.analyzeDocument(initialModelId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                analyzeRequest }));
        }, {
            initialModelId,
            options,
            transformResult: (result) => transformResult(toAnalyzeResultFromGenerated(result)),
        });
    }
    /**
     * Classify a document using a custom classifier given by its ID.
     *
     * This method produces a long-running operation (poller) that will eventually produce an `AnalyzeResult`. This is the
     * same type as `beginAnalyzeDocument` and `beginAnalyzeDocumentFromUrl`, but the result will only contain a small
     * subset of its fields. Only the `documents` field and `pages` field will be populated, and only minimal page
     * information will be returned. The `documents` field will contain information about all the identified documents and
     * the `docType` that they were classified as.
     *
     * ### Example
     *
     * This method supports streamable request bodies ({@link FormRecognizerRequestBody}) such as Node.JS `ReadableStream`
     * objects, browser `Blob`s, and `ArrayBuffer`s. The contents of the body will be uploaded to the service for analysis.
     *
     * ```typescript
     * import * as fs from "fs";
     *
     * const file = fs.createReadStream("path/to/file.pdf");
     *
     * const poller = await client.beginClassifyDocument("<classifier ID>", file);
     *
     * // The result is a long-running operation (poller), which must itself be polled until the operation completes
     * const {
     *   pages, // pages extracted from the document, which contain only basic information for classifiers
     *   documents // extracted documents and their types
     * } = await poller.pollUntilDone();
     *
     * // We'll print the documents and their types
     * for (const { docType } of documents) {
     *   console.log("The type of this document is:", docType);
     * }
     * ```
     *
     * @param classifierId - the ID of the custom classifier to use for analysis
     * @param document - the document to classify
     * @param options - options for the classification operation
     * @returns a long-running operation (poller) that will eventually produce an `AnalyzeResult`
     */
    async beginClassifyDocument(classifierId, document, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginClassifyDocument", options, this.classify.bind(this, classifierId, source("body", document)));
    }
    /**
     * Classify a document from a URL using a custom classifier given by its ID.
     *
     * This method produces a long-running operation (poller) that will eventually produce an `AnalyzeResult`. This is the
     * same type as `beginAnalyzeDocument` and `beginAnalyzeDocumentFromUrl`, but the result will only contain a small
     * subset of its fields. Only the `documents` field and `pages` field will be populated, and only minimal page
     * information will be returned. The `documents` field will contain information about all the identified documents and
     * the `docType` that they were classified as.
     *
     * ### Example
     *
     * This method supports extracting data from a file at a given URL. The Form Recognizer service will attempt to
     * download a file using the submitted URL, so the URL must be accessible from the public internet. For example, a SAS
     * token can be used to grant read access to a blob in Azure Storage, and the service will use the SAS-encoded URL to
     * request the file.
     *
     * ```typescript
     * // the URL must be publicly accessible
     * const url = "<file url>";
     *
     * const poller = await client.beginClassifyDocument("<classifier ID>", url);
     *
     * // The result is a long-running operation (poller), which must itself be polled until the operation completes
     * const {
     *   pages, // pages extracted from the document, which contain only basic information for classifiers
     *   documents // extracted documents and their types
     * } = await poller.pollUntilDone();
     *
     * // We'll print the documents and their types
     * for (const { docType } of documents) {
     *   console.log("The type of this document is:", docType);
     * }
     * ```
     * @param classifierId - the ID of the custom classifier to use for analysis
     * @param documentUrl - the URL of the document to classify
     * @param options -
     * @returns
     */
    async beginClassifyDocumentFromUrl(classifierId, documentUrl, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginClassifyDocumentFromUrl", options, this.classify.bind(this, classifierId, source("url", documentUrl)));
    }
    /**
     * A helper method for running classification polymorphically.
     * @param classifierId - the ID of the classifier to use
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns an analysis poller
     */
    classify(classifierId, input, options) {
        return this.createUnifiedPoller(async (abortSignal) => {
            const [contentType, classifyRequest] = toAnalyzeRequest(input);
            return this._restClient.documentClassifiers.classifyDocument(classifierId, contentType, Object.assign(Object.assign({}, options), { abortSignal,
                classifyRequest }));
        }, {
            initialModelId: classifierId,
            options,
            transformResult: toAnalyzeResultFromGenerated,
        });
    }
    /**
     * Create an LRO poller that handles analysis operations.
     *
     * This is the meat of all analysis polling operations.
     *
     * @param startOperation - function that starts the operation and returns the operation location
     * @param definition - operation definition (initial model ID, operation transforms, request options)
     * @returns - an analysis poller that produces the given return types according to the operation spec
     */
    async createUnifiedPoller(startOperation, definition) {
        const { resumeFrom } = definition.options;
        // TODO: what should we do if resumeFrom.modelId is different from initialModelId?
        // And what do we do with the redundant input??
        const getAnalyzeResult = (ctx, operationLocation) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-getAnalyzeResult", definition.options, (finalOptions) => this._restClient.sendOperationRequest({
            options: Object.assign(Object.assign({ onResponse: async (rawResponse, ...args) => {
                    var _a;
                    // Capture the `Retry-After` header if it was sent.
                    const retryAfterHeader = rawResponse.headers.get("retry-after");
                    // Convert the header value to milliseconds. If the header is not a valid number, then it is an HTTP
                    // date.
                    if (retryAfterHeader) {
                        const retryAfterMs = Number(retryAfterHeader) * 1000;
                        if (!Number.isNaN(retryAfterMs)) {
                            ctx.updateDelay(retryAfterMs);
                        }
                        else {
                            ctx.updateDelay(Date.parse(retryAfterHeader) - Date.now());
                        }
                    }
                    else {
                        ctx.updateDelay(undefined);
                    }
                    // Forward the `onResponse` callback if it was provided.
                    return (_a = finalOptions.onResponse) === null || _a === void 0 ? void 0 : _a.call(finalOptions, rawResponse, ...args);
                } }, finalOptions), { 
                // We need to pass the abort signal from the context rather than from the options, since the user could
                // poll the LRO with a different AbortSignal than it was instantiated with.
                abortSignal: ctx.abortSignal }),
        }, {
            path: operationLocation,
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: AnalyzeResultOperation,
                },
                default: {
                    bodyMapper: ErrorResponse,
                },
            },
            // URL is fully-formed, so we don't need any query parameters
            headerParameters: [accept1],
            serializer: SERIALIZER,
        }));
        const toInit = 
        // If the user gave us a stored token, we'll poll it again
        resumeFrom !== undefined
            ? async (ctx) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-resume", definition.options, async () => {
                const { clientVersion, operationLocation, modelId } = JSON.parse(resumeFrom);
                if (!clientVersion || clientVersion !== SDK_VERSION) {
                    throw new Error([
                        "Cannot restore poller from a serialized state from a different version of the client",
                        `library (restoreFrom: '${clientVersion}', current: '${SDK_VERSION}').`,
                    ].join(" "));
                }
                const result = await getAnalyzeResult(ctx, operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            })
            : // Otherwise, we'll start a new operation from the initialModelId
                async (ctx) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-start", definition.options, async () => {
                    const { operationLocation } = await startOperation(ctx.abortSignal);
                    if (operationLocation === undefined) {
                        throw new Error("Unable to start analysis operation: no Operation-Location received.");
                    }
                    const result = await getAnalyzeResult(ctx, operationLocation);
                    return toDocumentAnalysisPollOperationState(definition, definition.initialModelId, operationLocation, result);
                });
        const poller = await lro({
            init: toInit,
            poll: async (ctx, { operationLocation, modelId }) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-poll", {}, async () => {
                const result = await getAnalyzeResult(ctx, operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            }),
            serialize: ({ operationLocation, modelId }) => JSON.stringify({ clientVersion: SDK_VERSION, id: modelId, operationLocation }),
        }, definition.options.updateIntervalInMs, definition.options.abortSignal);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        return poller;
    }
}
/**
 * Produce an appropriate pair of content-type and analyzeRequest value for the analysis request.
 * @internal
 */
function toAnalyzeRequest(input) {
    switch (input.kind) {
        case "body":
            return ["application/octet-stream", input.body];
        case "url":
            return ["application/json", { urlSource: input.url }];
        case "base64":
            return ["application/json", { base64Source: input.base64 }];
        default: {
            const __exhaust = input;
            throw new Error(`Unreachable 'toAnalyzeRequest' case: ${__exhaust}`);
        }
    }
}
/**
 * The input to a document analysis operation.
 */
// type DocumentSource = DocumentBodySource | DocumentUrlSource | DocumentBase64Source;
function source(kind, value) {
    return {
        kind,
        [kind]: value,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Convert an operation result into a training poller state.
 * @internal
 */
async function toTrainingPollOperationState(response) {
    var _a;
    return {
        operationId: response.operationId,
        status: response.status,
        apiVersion: response.apiVersion,
        percentCompleted: (_a = response.percentCompleted) !== null && _a !== void 0 ? _a : 0,
        lastUpdatedOn: response.lastUpdatedOn,
        createdOn: response.createdOn,
        error: response.error && new FormRecognizerError(response.error),
        isCancelled: response.status === "canceled",
        isCompleted: response.status === "succeeded",
        isStarted: response.status !== "notStarted",
        tags: response.tags,
        // The following assertion is required. Technically the type of `response.result` is
        // `DocumentModelDetails | DocumentClassifierDetails | undefined`, which isn't assignable to the type of
        // either operation state's result. We would need some kind of dependent typing to express how the type of `result`
        // actually _determines_ the type of the resulting return value.
        result: response.result,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * A client for interacting with the Form Recognizer service's model management features, such as creating, reading,
 * listing, deleting, and copying models.
 *
 * ### Examples:
 *
 * #### Azure Active Directory
 *
 * ```typescript
 * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new DocumentModelAdministrationClient(endpoint, credential);
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```typescript
 * import { DocumentModelAdministrationClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new DocumentModelAdministrationClient(endpoint, credential);
 * ```
 */
class DocumentModelAdministrationClient {
    constructor(endpoint, credential, options = {}) {
        this._restClient = makeServiceClient(endpoint, credential, options);
        this._tracing = coreTracing.createTracingClient({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    async beginBuildDocumentModel(modelId, urlOrSource, buildMode, options = {}) {
        const sourceInfo = typeof urlOrSource === "string"
            ? {
                azureBlobSource: {
                    containerUrl: urlOrSource,
                },
            }
            : urlOrSource;
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginBuildDocumentModel", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: (ctx) => this._restClient.documentModels.buildModel(Object.assign(Object.assign({ modelId, description: finalOptions.description }, sourceInfo), { buildMode }), Object.assign(Object.assign({}, finalOptions), { abortSignal: ctx.abortSignal })),
        }));
    }
    /**
     * Creates a single composed model from several pre-existing submodels.
     *
     * The resulting composed model combines the document types of its component models, and inserts a classification step
     * into the extraction pipeline to determine which of its component submodels is most appropriate for the given input.
     *
     * ### Example
     *
     * ```javascript
     * const modelId = "aNewComposedModel";
     * const subModelIds = [
     *   "documentType1Model",
     *   "documentType2Model",
     *   "documentType3Model"
     * ];
     *
     * // The resulting composed model can classify and extract data from documents
     * // conforming to any of the above document types
     * const poller = await client.beginComposeDocumentModel(modelId, subModelIds, {
     *   description: "This is a composed model that can handle several document types."
     * });
     *
     * // Model composition, like all other model creation operations, returns a poller that eventually produces a
     * // ModelDetails object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the model
     *   description, // identical to the description given when creating the model
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes // information about the document types of the composed submodels
     * } = modelDetails;
     * ```
     *
     * @param modelId - the unique ID of the model to create
     * @param componentModelIds - an Iterable of strings representing the unique model IDs of the models to compose
     * @param options - optional settings for model creation
     * @returns a long-running operation (poller) that will eventually produce the created model information or an error
     */
    async beginComposeDocumentModel(modelId, componentModelIds, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginComposeDocumentModel", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: (ctx) => this._restClient.documentModels.composeModel({
                modelId,
                componentModels: [...componentModelIds].map((submodelId) => ({
                    modelId: submodelId,
                })),
                description: finalOptions.description,
                tags: finalOptions.tags,
            }, Object.assign(Object.assign({}, finalOptions), { abortSignal: ctx.abortSignal })),
        }));
    }
    /**
     * Creates an authorization to copy a model into the resource, used with the `beginCopyModelTo` method.
     *
     * The `CopyAuthorization` grants another cognitive service resource the right to create a model in this client's
     * resource with the model ID and optional description that are encoded into the authorization.
     *
     * ### Example
     *
     * ```javascript
     * // The copyAuthorization data structure stored below grants any cognitive services resource the right to copy a
     * // model into the client's resource with the given destination model ID.
     * const copyAuthorization = await client.getCopyAuthorization("<destination model ID>");
     * ```
     *
     * @param destinationModelId - the unique ID of the destination model (the ID to copy the model into)
     * @param options - optional settings for creating the copy authorization
     * @returns a copy authorization that encodes the given modelId and optional description
     */
    async getCopyAuthorization(destinationModelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getCopyAuthorization", options, (finalOptions) => this._restClient.documentModels.authorizeModelCopy({
            modelId: destinationModelId,
            description: finalOptions.description,
            tags: finalOptions.tags,
        }, finalOptions));
    }
    /**
     * Copies a model with the given ID into the resource and model ID encoded by a given copy authorization.
     *
     * See {@link CopyAuthorization} and {@link getCopyAuthorization}.
     *
     * ### Example
     *
     * ```javascript
     * // We need a client for the source model's resource
     * const sourceEndpoint = "https://<source resource name>.cognitiveservices.azure.com";
     * const sourceCredential = new AzureKeyCredential("<source api key>");
     * const sourceClient = new DocumentModelAdministrationClient(sourceEndpoint, sourceCredential);
     *
     * // We create the copy authorization using a client authenticated with the destination resource. Note that these two
     * // resources can be the same (you can copy a model to a new ID in the same resource).
     * const copyAuthorization = await client.getCopyAuthorization("<destination model ID>");
     *
     * // Finally, use the _source_ client to copy the model and await the copy operation
     * const poller = await sourceClient.beginCopyModelTo("<source model ID>");
     *
     * // Model copying, like all other model creation operations, returns a poller that eventually produces a ModelDetails
     * // object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the copy authorization
     *   description, // identical to the description given when creating the copy authorization
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes // information about the document types of the model (identical to the original, source model)
     * } = modelDetails;
     * ```
     *
     * @param sourceModelId - the unique ID of the source model that will be copied
     * @param authorization - an authorization to copy the model, created using the {@link getCopyAuthorization}
     * @param options - optional settings for
     * @returns a long-running operation (poller) that will eventually produce the copied model information or an error
     */
    async beginCopyModelTo(sourceModelId, authorization, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginCopyModel", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: () => this._restClient.documentModels.copyModelTo(sourceModelId, authorization, finalOptions),
        }));
    }
    // #endregion
    // #region Document Classifiers
    /**
     * Build a new document classifier with the given classifier ID and document types.
     *
     * The classifier ID must be unique among classifiers within the resource.
     *
     * The document types are given as an object that maps the name of the document type to the training data set for that
     * document type. Two training data input methods are supported:
     *
     * - `azureBlobSource`, which trains a classifier using the data in the given Azure Blob Storage container.
     * - `azureBlobFileListSource`, which is similar to `azureBlobSource` but allows for more fine-grained control over
     *   the files that are included in the training data set by using a JSONL-formatted file list.
     *
     * The Form Recognizer service reads the training data set from an Azure Storage container, given as a URL to the
     * container with a SAS token that allows the service backend to communicate with the container. At a minimum, the
     * "read" and "list" permissions are required. In addition, the data in the given container must be organized
     * according to a particular convention, which is documented in [the service's documentation for building custom
     * document classifiers](https://aka.ms/azsdk/formrecognizer/buildclassifiermodel).
     *
     * ### Example
     *
     * ```javascript
     * const classifierId = "aNewClassifier";
     * const containerUrl1 = "<training data container SAS URL 1>";
     * const containerUrl2 = "<training data container SAS URL 2>";
     *
     * const poller = await client.beginBuildDocumentClassifier(
     *   classifierId,
     *   {
     *     // The document types. Each entry in this object should map a document type name to a
     *     // `ClassifierDocumentTypeDetails` object
     *     "formX": {
     *       azureBlobSource: {
     *         containerUrl: containerUrl1,
     *       }
     *     },
     *     "formY": {
     *       azureBlobFileListSource: {
     *         containerUrl: containerUrl2,
     *         fileList: "path/to/fileList.jsonl"
     *       }
     *     },
     *   },
     *   {
     *     // Optionally, a text description may be attached to the classifier
     *     description: "This is an example classifier!"
     *   }
     * );
     *
     * // Classifier building, like model creation operations, returns a poller that eventually produces a
     * // DocumentClassifierDetails object
     * const classifierDetails = await poller.pollUntilDone();
     *
     * const {
     *   classifierId, // identical to the classifierId given when creating the classifier
     *   description, // identical to the description given when creating the classifier (if any)
     *   createdOn, // the Date (timestamp) that the classifier was created
     *   docTypes // information about the document types in the classifier and their details
     * } = classifierDetails;
     * ```
     *
     * @param classifierId - the unique ID of the classifier to create
     * @param docTypeSources - the document types to include in the classifier and their sources (a map of document type
     *                         names to `ClassifierDocumentTypeDetails`)
     * @param options - optional settings for the classifier build operation
     * @returns a long-running operation (poller) that will eventually produce the created classifier details or an error
     */
    async beginBuildDocumentClassifier(classifierId, docTypeSources, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginBuildDocumentClassifier", options, (finalOptions) => this.createAdministrationPoller({
            options: finalOptions,
            start: () => this._restClient.documentClassifiers.buildClassifier({
                classifierId,
                description: finalOptions.description,
                docTypes: docTypeSources,
            }, finalOptions),
        }));
    }
    // #endregion
    /**
     * Create an LRO poller that handles model creation operations.
     *
     * This is the meat of the above model creation operations.
     *
     * @param definition - operation definition (start operation method, request options)
     * @returns a model poller (produces a ModelDetails)
     */
    async createAdministrationPoller(definition) {
        const { resumeFrom } = definition.options;
        const toInit = resumeFrom === undefined
            ? (ctx) => this._tracing.withSpan("DocumentModelAdministrationClient.createDocumentModelPoller-start", definition.options, async (options) => {
                const { operationLocation } = await definition.start(ctx);
                if (operationLocation === undefined) {
                    throw new Error("Unable to start model creation operation: no Operation-Location received.");
                }
                return this._restClient.sendOperationRequest({
                    options: Object.assign(Object.assign({ onResponse: (rawResponse, ...args) => {
                            return captureRetryAfter(rawResponse, ctx, options, args);
                        } }, options), { abortSignal: ctx.abortSignal }),
                }, {
                    path: operationLocation,
                    httpMethod: "GET",
                    responses: {
                        200: {
                            bodyMapper: OperationDetails,
                        },
                        default: {
                            bodyMapper: ErrorResponse,
                        },
                    },
                    headerParameters: [accept1],
                    serializer: SERIALIZER,
                });
            })
            : (ctx) => this._tracing.withSpan("DocumentModelAdministrationClient.createDocumentModelPoller-resume", definition.options, (options) => {
                const { operationId } = JSON.parse(resumeFrom);
                return this._restClient.miscellaneous.getOperation(operationId, Object.assign({ onResponse: (rawResponse, ...args) => {
                        return captureRetryAfter(rawResponse, ctx, options, args);
                    } }, options));
            });
        const poller = await lro({
            init: async (ctx) => toTrainingPollOperationState(await toInit(ctx)),
            poll: async (ctx, { operationId }) => this._tracing.withSpan("DocumentModelAdminstrationClient.createDocumentModelPoller-poll", definition.options, async (options) => {
                const res = await this._restClient.miscellaneous.getOperation(operationId, Object.assign(Object.assign({ onResponse: (rawResponse, ...args) => {
                        // Capture the `Retry-After` header if it was sent.
                        return captureRetryAfter(rawResponse, ctx, options, args);
                    } }, options), { abortSignal: ctx.abortSignal }));
                return toTrainingPollOperationState(res);
            }),
            serialize: ({ operationId }) => JSON.stringify({ operationId }),
        }, definition.options.updateIntervalInMs, definition.options.abortSignal);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        // Need this assertion. The poller above is dynamic, and we can't infer the conditional return type of this method.
        return poller;
        /**
         * An inline helper for capturing the value of the `Retry-After` header if it was sent.
         * @param rawResponse - the raw response from the service
         * @param ctx - the operation context
         * @param options - the operation options
         * @param args - the arguments passed to the response handler
         * @returns
         */
        function captureRetryAfter(rawResponse, ctx, options, args) {
            var _a;
            const retryAfterHeader = rawResponse.headers.get("retry-after");
            // Convert the header value to milliseconds. If the header is not a valid number, then it is an HTTP
            // date.
            if (retryAfterHeader) {
                const retryAfterMs = Number(retryAfterHeader) * 1000;
                if (!Number.isNaN(retryAfterMs)) {
                    ctx.updateDelay(retryAfterMs);
                }
                else {
                    ctx.updateDelay(Date.parse(retryAfterHeader) - Date.now());
                }
            }
            else {
                ctx.updateDelay(undefined);
            }
            // Forward the `onResponse` callback if it was provided.
            return (_a = options.onResponse) === null || _a === void 0 ? void 0 : _a.call(options, rawResponse, ...args);
        }
    }
    // #region Model Management
    /**
     * Retrieve basic information about this client's resource.
     *
     * ### Example
     *
     * ```javascript
     * const {
     *   // Information about the custom models in the current resource
     *   customDocumentModelDetails: {
     *     // The number of custom models in the current resource
     *     count,
     *     // The maximum number of models that the current resource can support
     *     limit
     *   }
     * } = await client.getResourceDetails();
     * ```
     *
     * @param options - optional settings for the request
     * @returns basic information about this client's resource
     */
    getResourceDetails(options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getResourceDetails", options, (finalOptions) => this._restClient.miscellaneous.getResourceInfo(finalOptions));
    }
    /**
     * Retrieves information about a model ({@link DocumentModelDetails}) by ID.
     *
     * This method can retrieve information about custom as well as prebuilt models.
     *
     * ### **Breaking Change**
     *
     * In previous versions of the Form Recognizer REST API and SDK, the `getModel` method could return any model, even
     * one that failed to create due to errors. In the new service versions, `getDocumentModel` and `listDocumentModels`
     * _only produce successfully created models_ (i.e. models that are "ready" for use). Failed models are now retrieved
     * through the "operations" APIs, see {@link getOperation} and {@link listOperations}.
     *
     * ### Example
     *
     * ```javascript
     * // The ID of the prebuilt business card model
     * const modelId = "prebuilt-businessCard";
     *
     * const {
     *   modelId, // identical to the modelId given when calling `getDocumentModel`
     *   description, // a textual description of the model, if provided during model creation
     *   createdOn, // the Date (timestamp) that the model was created
     *   // information about the document types in the model and their field schemas
     *   docTypes: {
     *     // the document type of the prebuilt business card model
     *     "prebuilt:businesscard": {
     *       // an optional, textual description of this document type
     *       description,
     *       // the schema of the fields in this document type, see the FieldSchema type
     *       fieldSchema,
     *       // the service's confidences in the fields (an object with field names as properties and numeric confidence
     *       // values)
     *       fieldConfidence
     *     }
     *   }
     * } = await client.getDocumentModel(modelId);
     * ```
     *
     * @param modelId - the unique ID of the model to query
     * @param options - optional settings for the request
     * @returns information about the model with the given ID
     */
    getDocumentModel(modelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getDocumentModel", options, (finalOptions) => this._restClient.documentModels.getModel(modelId, finalOptions));
    }
    /**
     * List summaries of models in the resource. Custom as well as prebuilt models will be included. This operation
     * supports paging.
     *
     * The model summary ({@link DocumentModelSummary}) includes only the basic information about the model, and does not include
     * information about the document types in the model (such as the field schemas and confidence values).
     *
     * To access the full information about the model, use {@link getDocumentModel}.
     *
     * ### **Breaking Change**
     *
     * In previous versions of the Form Recognizer REST API and SDK, the `listModels` method would return all models, even
     * those that failed to create due to errors. In the new service versions, `listDocumentModels` and `getDocumentModel`
     * _only produce successfully created models_ (i.e. models that are "ready" for use). Failed models are now retrieved
     * through the "operations" APIs, see {@link getOperation} and {@link listOperations}.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```javascript
     * for await (const summary of client.listDocumentModels()) {
     *   const {
     *     modelId, // The model's unique ID
     *     description, // a textual description of the model, if provided during model creation
     *   } = summary;
     *
     *   // You can get the full model info using `getDocumentModel`
     *   const model = await client.getDocumentModel(modelId);
     * }
     * ```
     *
     * #### By Page
     *
     * ```javascript
     * // The listDocumentModels method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listDocumentModels().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of models and can be iterated synchronously
     *   for (const model of page) {
     *     const {
     *       modelId, // The model's unique ID
     *       description, // a textual description of the model, if provided during model creation
     *     } = summary;
     *
     *     // You can get the full model info using `getDocumentModel`
     *     const model = await client.getDocumentModel(modelId);
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the model requests
     * @returns an async iterable of model summaries that supports paging
     */
    listDocumentModels(options = {}) {
        return this._restClient.documentModels.listModels(options);
    }
    /**
     * Deletes a model with the given ID from the client's resource, if it exists. This operation CANNOT be reverted.
     *
     * ### Example
     *
     * ```javascript
     * await client.deleteDocumentModel("<model ID to delete>"));
     * ```
     *
     * @param modelId - the unique ID of the model to delete from the resource
     * @param options - optional settings for the request
     */
    deleteDocumentModel(modelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.deleteDocumentModel", options, (finalOptions) => this._restClient.documentModels.deleteModel(modelId, finalOptions));
    }
    // #endregion
    // #region Classifier Management
    /**
     * Retrieves information about a classifier ({@link DocumentClassifierDetails}) by ID.
     *
     * ### Example
     *
     * ```javascript
     * const classifierId = "<classifier ID";
     *
     * const {
     *   classifierId, // identical to the ID given when calling `getDocumentClassifier`
     *   description, // a textual description of the classifier, if provided during classifier creation
     *   createdOn, // the Date (timestamp) that the classifier was created
     *   // information about the document types in the classifier and their corresponding traning data
     *   docTypes
     * } = await client.getDocumentClassifier(classifierId);
     *
     * // The `docTypes` property is a map of document type names to information about the training data
     * // for that document type.
     * for (const [docTypeName, classifierDocTypeDetails] of Object.entries(docTypes)) {
     *  console.log(`- '${docTypeName}': `, classifierDocTypeDetails);
     * }
     * ```
     *
     * @param classifierId - the unique ID of the classifier to query
     * @param options - optional settings for the request
     * @returns information about the classifier with the given ID
     */
    getDocumentClassifier(classifierId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getDocumentClassifier", options, (finalOptions) => this._restClient.documentClassifiers.getClassifier(classifierId, finalOptions));
    }
    /**
     * List details about classifiers in the resource. This operation supports paging.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```javascript
     * for await (const details of client.listDocumentClassifiers()) {
     *   const {
     *     classifierId, // The classifier's unique ID
     *     description, // a textual description of the classifier, if provided during creation
     *     docTypes, // information about the document types in the classifier and their corresponding traning data
     *   } = details;
     * }
     * ```
     *
     * #### By Page
     *
     * ```javascript
     * // The listDocumentClassifiers method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listDocumentClassifiers().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of classifiers and can be iterated synchronously
     *   for (const details of page) {
     *     const {
     *       classifierId, // The classifier's unique ID
     *       description, // a textual description of the classifier, if provided during creation
     *       docTypes, // information about the document types in the classifier and their corresponding traning data
     *     } = details;
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the classifier requests
     * @returns an async iterable of classifier details that supports paging
     */
    listDocumentClassifiers(options = {}) {
        return this._restClient.documentClassifiers.listClassifiers(options);
    }
    /**
     * Deletes a classifier with the given ID from the client's resource, if it exists. This operation CANNOT be reverted.
     *
     * ### Example
     *
     * ```javascript
     * await client.deleteDocumentClassifier("<classifier ID to delete>"));
     * ```
     *
     * @param classifierId - the unique ID of the classifier to delete from the resource
     * @param options - optional settings for the request
     */
    deleteDocumentClassifier(classifierId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.deleteDocumentClassifier", options, (finalOptions) => this._restClient.documentClassifiers.deleteClassifier(classifierId, finalOptions));
    }
    // #endregion
    // #region Operations
    /**
     * Retrieves information about an operation (`OperationDetails`) by its ID.
     *
     * Operations represent non-analysis tasks, such as building, composing, or copying a model.
     *
     * @param operationId - the ID of the operation to query
     * @param options - optional settings for the request
     * @returns information about the operation with the given ID
     *
     * ### Example
     *
     * ```javascript
     * // The ID of the operation, which should be a GUID
     * const operationId = "<operation GUID>";
     *
     * const {
     *   operationId, // identical to the operationId given when calling `getOperation`
     *   kind, // the operation kind, one of "documentModelBuild", "documentModelCompose", or "documentModelCopyTo"
     *   status, // the status of the operation, one of "notStarted", "running", "failed", "succeeded", or "canceled"
     *   percentCompleted, // a number between 0 and 100 representing the progress of the operation
     *   createdOn, // a Date object that reflects the time when the operation was started
     *   lastUpdatedOn, // a Date object that reflects the time when the operation state was last modified
     * } = await client.getOperation(operationId);
     * ```
     */
    getOperation(operationId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getOperation", options, (finalOptions) => this._restClient.miscellaneous.getOperation(operationId, finalOptions));
    }
    /**
     * List model creation operations in the resource. This will produce all operations, including operations that failed
     * to create models successfully. This operation supports paging.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```javascript
     * for await (const operation of client.listOperations()) {
     *   const {
     *     operationId, // the operation's GUID
     *     status, // the operation status, one of "notStarted", "running", "succeeded", "failed", or "canceled"
     *     percentCompleted // the progress of the operation, from 0 to 100
     *   } = operation;
     * }
     * ```
     *
     * #### By Page
     *
     * ```javascript
     * // The listOperations method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listOperations().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of operation info objects and can be iterated synchronously
     *   for (const operation of page) {
     *     const {
     *       operationId, // the operation's GUID
     *       status, // the operation status, one of "notStarted", "running", "succeeded", "failed", or "canceled"
     *       percentCompleted // the progress of the operation, from 0 to 100
     *     } = operation;
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the operation requests
     * @returns an async iterable of operation information objects that supports paging
     */
    listOperations(options = {}) {
        return this._restClient.miscellaneous.listOperations(options);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Known feature flags supported by the Form Recognizer clients.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const FormRecognizerFeature = {
    /**
     * Enables extracting extra font information.
     */
    Fonts: "styleFont",
    /**
     * Enables high-resolution processing for documents with small text.
     */
    OcrHighResolution: "ocrHighResolution",
    /**
     * Enables the detection of mathematical expressions in the document..
     */
    Formulas: "formulas",
    /**
     * Enables the detection of the text content language.
     */
    Languages: "languages",
    /**
     *  Enables the detection of barcodes in the document.
     */
    Barcodes: "barcodes",
    /**
     *  Enables the detection of general key value pairs (form fields) in the document.
     */
    KeyValuePairs: "keyValuePairs",
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Supported values of `DocumentModelBuildMode`.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const DocumentModelBuildMode = {
    /**
     * A mode that builds a model assuming that documents all follow the same, fixed template layout (the same relative
     * positioning of fields between documents).
     */
    Template: "template",
    /**
     * A mode that uses a neural engine to extract fields, allowing for documents that have different visual appearances,
     * but that contain the same information.
     */
    Neural: "neural",
};

// Copyright (c) Microsoft Corporation.
/**
 * Checks a field value against a schema and converts it into a strong idiomatic DocumentField,
 * @internal
 * @param fieldName - the name of the field (used in diagnostics)
 * @param schema - the field's schema
 * @param field - the raw DocumentField value
 * @returns
 */
function extractField(fieldName, schema, field) {
    if (schema.type !== field.kind) {
        throw new Error(`Schema violation: ${fieldName} had type "${field.kind}", but expected "${schema.type}"`);
    }
    // Objects need to be handled specially, so that we can camelCase the field names.
    if (field.kind === "object") {
        const result = {};
        for (const [subFieldName, subFieldSchema] of Object.entries(schema.properties)) {
            if (field.properties[subFieldName] !== undefined && field.properties[subFieldName] !== null) {
                const trueFieldName = (isAcronymic(subFieldName) ? subFieldName : uncapitalize(subFieldName)).replace(/\s/g, "");
                result[trueFieldName] = extractField(fieldName + "." + subFieldName, subFieldSchema, field.properties[subFieldName]);
            }
        }
        return Object.assign(Object.assign({}, field), { properties: result });
    }
    else if (field.kind === "array") {
        return Object.assign(Object.assign({}, field), { values: field.values.map((val, idx) => extractField(fieldName + "[" + idx + "]", schema.items, val)) });
    }
    else
        return field;
}
/**
 * Create a DocumentModel that performs analysis using the given schema.
 *
 * The types of `documents` are created from the schema, so they are `unknown` unless they are asserted to be a
 * different type.
 *
 * @hidden
 * @param schema - model schema contents
 * @returns - a DocumentModel that encodes the schema
 */
function createModelFromSchema(schema) {
    return {
        modelId: schema.modelId,
        apiVersion: schema.apiVersion,
        transformResult(baseResult) {
            var _a, _b, _c;
            const hasDocuments = Object.entries((_a = schema.docTypes) !== null && _a !== void 0 ? _a : {}).length > 0;
            return Object.assign(Object.assign({}, baseResult), { documents: hasDocuments
                    ? (_b = baseResult.documents) === null || _b === void 0 ? void 0 : _b.map(toDocument)
                    : (_c = baseResult.documents) !== null && _c !== void 0 ? _c : [] });
            function toDocument(document) {
                var _a;
                const result = {};
                const model = (_a = schema.docTypes) === null || _a === void 0 ? void 0 : _a[document.docType];
                if (model === undefined) {
                    throw new Error(`Unexpected document type "${document.docType}" in result using model "${schema.modelId}"`);
                }
                for (const [fieldName, fieldSchema] of Object.entries(model.fieldSchema)) {
                    if (document.fields &&
                        document.fields[fieldName] !== undefined &&
                        document.fields[fieldName] !== null) {
                        const trueFieldName = (isAcronymic(fieldName) ? fieldName : uncapitalize(fieldName)).replace(/\s/g, "");
                        result[trueFieldName] = extractField(fieldName, fieldSchema, document.fields[fieldName]);
                    }
                }
                return Object.assign(Object.assign({}, document), { fields: result });
            }
        },
    };
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.DocumentAnalysisClient = DocumentAnalysisClient;
exports.DocumentModelAdministrationClient = DocumentModelAdministrationClient;
exports.DocumentModelBuildMode = DocumentModelBuildMode;
exports.FormRecognizerFeature = FormRecognizerFeature;
exports.StringIndexType = StringIndexType;
exports.createModelFromSchema = createModelFromSchema;
//# sourceMappingURL=index.js.map
