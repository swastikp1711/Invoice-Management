'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure-rest/core-client');
var logger$1 = require('@azure/logger');
var corePaging = require('@azure/core-paging');
var coreLro = require('@azure/core-lro');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const logger = logger$1.createClientLogger("ai-document-intelligence");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Initialize a new instance of `DocumentIntelligenceClient`
 * @param endpoint - The Document Intelligence service endpoint.
 * @param credentials - uniquely identify client credential
 * @param options - the parameter for all optional parameters
 */
function createClient(endpoint, credentials, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const baseUrl = (_a = options.baseUrl) !== null && _a !== void 0 ? _a : `${endpoint}/documentintelligence`;
    options.apiVersion = (_b = options.apiVersion) !== null && _b !== void 0 ? _b : "2024-02-29-preview";
    const userAgentInfo = `azsdk-js-ai-document-intelligence-rest/1.0.0-beta.2`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}`
        : `${userAgentInfo}`;
    options = Object.assign(Object.assign({}, options), { userAgentOptions: {
            userAgentPrefix,
        }, loggingOptions: {
            logger: (_d = (_c = options.loggingOptions) === null || _c === void 0 ? void 0 : _c.logger) !== null && _d !== void 0 ? _d : logger.info,
        }, credentials: {
            scopes: (_f = (_e = options.credentials) === null || _e === void 0 ? void 0 : _e.scopes) !== null && _f !== void 0 ? _f : ["https://cognitiveservices.azure.com/.default"],
            apiKeyHeaderName: (_h = (_g = options.credentials) === null || _g === void 0 ? void 0 : _g.apiKeyHeaderName) !== null && _h !== void 0 ? _h : "Ocp-Apim-Subscription-Key",
        } });
    const client = coreClient.getClient(baseUrl, credentials, options);
    return client;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const responseMap = {
    "GET /operations": ["200"],
    "GET /operations/{operationId}": ["200"],
    "GET /info": ["200"],
    "GET /documentModels/{modelId}/analyzeResults/{resultId}": ["200"],
    "POST /documentModels/{modelId}:analyze": ["202"],
    "GET /documentModels/{modelId}:analyze": ["200", "202"],
    "GET /documentModels/{modelId}": ["200"],
    "DELETE /documentModels/{modelId}": ["204"],
    "POST /documentModels:build": ["202"],
    "GET /documentModels:build": ["200", "202"],
    "POST /documentModels:compose": ["202"],
    "GET /documentModels:compose": ["200", "202"],
    "POST /documentModels:authorizeCopy": ["200"],
    "POST /documentModels/{modelId}:copyTo": ["202"],
    "GET /documentModels/{modelId}:copyTo": ["200", "202"],
    "GET /documentModels": ["200"],
    "POST /documentClassifiers:build": ["202"],
    "GET /documentClassifiers:build": ["200", "202"],
    "GET /documentClassifiers": ["200"],
    "GET /documentClassifiers/{classifierId}": ["200"],
    "DELETE /documentClassifiers/{classifierId}": ["204"],
    "POST /documentClassifiers/{classifierId}:analyze": ["202"],
    "GET /documentClassifiers/{classifierId}:analyze": ["200", "202"],
    "GET /documentClassifiers/{classifierId}/analyzeResults/{resultId}": ["200"],
};
function isUnexpected(response) {
    const lroOriginal = response.headers["x-ms-original-url"];
    const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
    const method = response.request.method;
    let pathDetails = responseMap[`${method} ${url.pathname}`];
    if (!pathDetails) {
        pathDetails = getParametrizedPathSuccess(method, url.pathname);
    }
    return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path) {
    var _a, _b, _c, _d;
    const pathParts = path.split("/");
    // Traverse list to match the longest candidate
    // matchedLen: the length of candidate path
    // matchedValue: the matched status code array
    let matchedLen = -1, matchedValue = [];
    // Iterate the responseMap to find a match
    for (const [key, value] of Object.entries(responseMap)) {
        // Extracting the path from the map key which is in format
        // GET /path/foo
        if (!key.startsWith(method)) {
            continue;
        }
        const candidatePath = getPathFromMapKey(key);
        // Get each part of the url path
        const candidateParts = candidatePath.split("/");
        // track if we have found a match to return the values found.
        let found = true;
        for (let i = candidateParts.length - 1, j = pathParts.length - 1; i >= 1 && j >= 1; i--, j--) {
            if (((_a = candidateParts[i]) === null || _a === void 0 ? void 0 : _a.startsWith("{")) && ((_b = candidateParts[i]) === null || _b === void 0 ? void 0 : _b.indexOf("}")) !== -1) {
                const start = candidateParts[i].indexOf("}") + 1, end = (_c = candidateParts[i]) === null || _c === void 0 ? void 0 : _c.length;
                // If the current part of the candidate is a "template" part
                // Try to use the suffix of pattern to match the path
                // {guid} ==> $
                // {guid}:export ==> :export$
                const isMatched = new RegExp(`${(_d = candidateParts[i]) === null || _d === void 0 ? void 0 : _d.slice(start, end)}`).test(pathParts[j] || "");
                if (!isMatched) {
                    found = false;
                    break;
                }
                continue;
            }
            // If the candidate part is not a template and
            // the parts don't match mark the candidate as not found
            // to move on with the next candidate path.
            if (candidateParts[i] !== pathParts[j]) {
                found = false;
                break;
            }
        }
        // We finished evaluating the current candidate parts
        // Update the matched value if and only if we found the longer pattern
        if (found && candidatePath.length > matchedLen) {
            matchedLen = candidatePath.length;
            matchedValue = value;
        }
    }
    return matchedValue;
}
function getPathFromMapKey(mapKey) {
    const pathStart = mapKey.indexOf("/");
    return mapKey.slice(pathStart);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper to paginate results from an initial response that follows the specification of Autorest `x-ms-pageable` extension
 * @param client - Client to use for sending the next page requests
 * @param initialResponse - Initial response containing the nextLink and current page of elements
 * @param customGetPage - Optional - Function to define how to extract the page and next link to be used to paginate the results
 * @returns - PagedAsyncIterableIterator to iterate the elements
 */
function paginate(client, initialResponse, options = {}) {
    let firstRun = true;
    const itemName = "value";
    const nextLinkName = "nextLink";
    const { customGetPage } = options;
    const pagedResult = {
        firstPageLink: "",
        getPage: typeof customGetPage === "function"
            ? customGetPage
            : async (pageLink) => {
                const result = firstRun ? initialResponse : await client.pathUnchecked(pageLink).get();
                firstRun = false;
                checkPagingRequest(result);
                const nextLink = getNextLink(result.body, nextLinkName);
                const values = getElements(result.body, itemName);
                return {
                    page: values,
                    nextPageLink: nextLink,
                };
            },
    };
    return corePaging.getPagedAsyncIterator(pagedResult);
}
/**
 * Gets for the value of nextLink in the body
 */
function getNextLink(body, nextLinkName) {
    if (!nextLinkName) {
        return undefined;
    }
    const nextLink = body[nextLinkName];
    if (typeof nextLink !== "string" && typeof nextLink !== "undefined") {
        throw new Error(`Body Property ${nextLinkName} should be a string or undefined`);
    }
    return nextLink;
}
/**
 * Gets the elements of the current request in the body.
 */
function getElements(body, itemName) {
    const value = body[itemName];
    // value has to be an array according to the x-ms-pageable extension.
    // The fact that this must be an array is used above to calculate the
    // type of elements in the page in PaginateReturn
    if (!Array.isArray(value)) {
        throw new Error(`Couldn't paginate response\n Body doesn't contain an array property with name: ${itemName}`);
    }
    return value !== null && value !== void 0 ? value : [];
}
/**
 * Checks if a request failed
 */
function checkPagingRequest(response) {
    const Http2xxStatusCodes = ["200", "201", "202", "203", "204", "205", "206", "207", "208", "226"];
    if (!Http2xxStatusCodes.includes(response.status)) {
        throw coreClient.createRestError(`Pagination failed with unexpected statusCode ${response.status}`, response);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
async function getLongRunningPoller(client, initialResponse, options = {}) {
    var _a;
    const poller = {
        requestMethod: initialResponse.request.method,
        requestPath: initialResponse.request.url,
        sendInitialRequest: async () => {
            // In the case of Rest Clients we are building the LRO poller object from a response that's the reason
            // we are not triggering the initial request here, just extracting the information from the
            // response we were provided.
            return getLroResponse(initialResponse);
        },
        sendPollRequest: async (path) => {
            // This is the callback that is going to be called to poll the service
            // to get the latest status. We use the client provided and the polling path
            // which is an opaque URL provided by caller, the service sends this in one of the following headers: operation-location, azure-asyncoperation or location
            // depending on the lro pattern that the service implements. If non is provided we default to the initial path.
            const response = await client.pathUnchecked(path !== null && path !== void 0 ? path : initialResponse.request.url).get();
            const lroResponse = getLroResponse(response);
            lroResponse.rawResponse.headers["x-ms-original-url"] = initialResponse.request.url;
            return lroResponse;
        },
    };
    options.resolveOnUnsuccessful = (_a = options.resolveOnUnsuccessful) !== null && _a !== void 0 ? _a : true;
    return coreLro.createHttpPoller(poller, options);
}
/**
 * Converts a Rest Client response to a response that the LRO implementation understands
 * @param response - a rest client http response
 * @returns - An LRO response that the LRO implementation understands
 */
function getLroResponse(response) {
    if (Number.isNaN(response.status)) {
        throw new TypeError(`Status code of the response is not a number. Value: ${response.status}`);
    }
    return {
        flatResponse: response,
        rawResponse: Object.assign(Object.assign({}, response), { statusCode: Number.parseInt(response.status), body: response.body }),
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

exports.default = createClient;
exports.getLongRunningPoller = getLongRunningPoller;
exports.isUnexpected = isUnexpected;
exports.paginate = paginate;
//# sourceMappingURL=index.js.map
