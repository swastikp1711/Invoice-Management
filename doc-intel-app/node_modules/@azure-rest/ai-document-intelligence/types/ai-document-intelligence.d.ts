/// <reference types="node" />

import { Client } from '@azure-rest/core-client';
import { ClientOptions } from '@azure-rest/core-client';
import { CreateHttpPollerOptions } from '@azure/core-lro';
import { HttpResponse } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationState } from '@azure/core-lro';
import { Paged } from '@azure/core-paging';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { RawHttpHeaders } from '@azure/core-rest-pipeline';
import { RawHttpHeadersInput } from '@azure/core-rest-pipeline';
import { RequestParameters } from '@azure-rest/core-client';
import { SimplePollerLike } from '@azure/core-lro';
import { StreamableMethod } from '@azure-rest/core-client';
import { TokenCredential } from '@azure/core-auth';

/** Address field value. */
export declare interface AddressValueOutput {
    /** House or building number. */
    houseNumber?: string;
    /** Post office box number. */
    poBox?: string;
    /** Street name. */
    road?: string;
    /** Name of city, town, village, etc. */
    city?: string;
    /** First-level administrative division. */
    state?: string;
    /** Postal code used for mail sorting. */
    postalCode?: string;
    /** Country/region. */
    countryRegion?: string;
    /** Street-level address, excluding city, state, countryRegion, and postalCode. */
    streetAddress?: string;
    /** Apartment or office number */
    unit?: string;
    /**
     * Districts or boroughs within a city, such as Brooklyn in New York City or City
     * of Westminster in London.
     */
    cityDistrict?: string;
    /** Second-level administrative division used in certain locales. */
    stateDistrict?: string;
    /** Unofficial neighborhood name, like Chinatown. */
    suburb?: string;
    /** Build name, such as World Trade Center. */
    house?: string;
    /** Floor number, such as 3F. */
    level?: string;
}

export declare interface AnalyzeDocument202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface AnalyzeDocument202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & AnalyzeDocument202Headers;
}

export declare interface AnalyzeDocumentBodyParam {
    /** Analyze request parameters. */
    body?: AnalyzeDocumentRequest;
}

export declare interface AnalyzeDocumentDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface AnalyzeDocumentFromStream {
    /** Analyzes document with document model. */
    post(options: AnalyzeDocumentFromStreamParameters): StreamableMethod<AnalyzeDocumentFromStream202Response | AnalyzeDocumentFromStreamDefaultResponse>;
    /** Analyzes document with document model. */
    post(options: AnalyzeDocumentParameters): StreamableMethod<AnalyzeDocument202Response | AnalyzeDocumentDefaultResponse>;
}

export declare interface AnalyzeDocumentFromStream202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface AnalyzeDocumentFromStream202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & AnalyzeDocumentFromStream202Headers;
}

export declare interface AnalyzeDocumentFromStreamBodyParam {
    /**
     * Input content.
     *
     * Value may contain any sequence of octets
     */
    body: string | Uint8Array | ReadableStream<Uint8Array> | NodeJS.ReadableStream;
}

export declare interface AnalyzeDocumentFromStreamDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

/** The final response for long-running analyzeDocumentFromStream operation */
export declare interface AnalyzeDocumentFromStreamLogicalResponse extends HttpResponse {
    status: "200";
}

export declare interface AnalyzeDocumentFromStreamMediaTypesParam {
    /** Input content type. */
    contentType: "application/octet-stream" | "application/pdf" | "image/jpeg" | "image/png" | "image/tiff" | "image/bmp" | "image/heif" | "text/html" | "application/vnd.openxmlformats-officedocument.wordprocessingml.document" | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" | "application/vnd.openxmlformats-officedocument.presentationml.presentation";
}

export declare type AnalyzeDocumentFromStreamParameters = AnalyzeDocumentFromStreamQueryParam & AnalyzeDocumentFromStreamMediaTypesParam & AnalyzeDocumentFromStreamBodyParam & RequestParameters;

export declare interface AnalyzeDocumentFromStreamQueryParam {
    queryParameters?: AnalyzeDocumentFromStreamQueryParamProperties;
}

export declare interface AnalyzeDocumentFromStreamQueryParamProperties {
    /** List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9" */
    pages?: string;
    /**
     * Locale hint for text recognition and document analysis.  Value may contain only
     * the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").
     */
    locale?: string;
    /**
     * Method used to compute string offset and length.
     *
     * Possible values: "textElements", "unicodeCodePoint", "utf16CodeUnit"
     */
    stringIndexType?: string;
    /** List of optional analysis features. */
    features?: string[];
    /** List of additional fields to extract.  Ex. "NumberOfGuests,StoreNumber" */
    queryFields?: string[];
    /**
     * Format of the analyze result top-level content.
     *
     * Possible values: "text", "markdown"
     */
    outputContentFormat?: string;
}

/** The final response for long-running analyzeDocument operation */
export declare interface AnalyzeDocumentLogicalResponse extends HttpResponse {
    status: "200";
}

export declare interface AnalyzeDocumentMediaTypesParam {
    /** Input content type */
    contentType: "application/json";
}

export declare type AnalyzeDocumentParameters = AnalyzeDocumentQueryParam & AnalyzeDocumentMediaTypesParam & AnalyzeDocumentBodyParam & RequestParameters;

export declare interface AnalyzeDocumentQueryParam {
    queryParameters?: AnalyzeDocumentQueryParamProperties;
}

export declare interface AnalyzeDocumentQueryParamProperties {
    /** List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9" */
    pages?: string;
    /**
     * Locale hint for text recognition and document analysis.  Value may contain only
     * the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").
     */
    locale?: string;
    /**
     * Method used to compute string offset and length.
     *
     * Possible values: "textElements", "unicodeCodePoint", "utf16CodeUnit"
     */
    stringIndexType?: string;
    /** List of optional analysis features. */
    features?: string[];
    /** List of additional fields to extract.  Ex. "NumberOfGuests,StoreNumber" */
    queryFields?: string[];
    /**
     * Format of the analyze result top-level content.
     *
     * Possible values: "text", "markdown"
     */
    outputContentFormat?: string;
}

/** Document analysis parameters. */
export declare interface AnalyzeDocumentRequest {
    /** Document URL to analyze.  Either urlSource or base64Source must be specified. */
    urlSource?: string;
    /**
     * Base64 encoding of the document to analyze.  Either urlSource or base64Source
     * must be specified.
     */
    base64Source?: string;
}

/** Status and result of the analyze operation. */
export declare interface AnalyzeResultOperationOutput {
    /**
     * Operation status.  notStarted, running, succeeded, or failed
     *
     * Possible values: "notStarted", "running", "failed", "succeeded", "completed", "canceled"
     */
    status: string;
    /** Date and time (UTC) when the analyze operation was submitted. */
    createdDateTime: string;
    /** Date and time (UTC) when the status was last updated. */
    lastUpdatedDateTime: string;
    /** Encountered error during document analysis. */
    error?: ErrorModelOutput;
    /** Document analysis result. */
    analyzeResult?: AnalyzeResultOutput;
}

/** Document analysis result. */
export declare interface AnalyzeResultOutput {
    /** API version used to produce this result. */
    apiVersion: string;
    /** Document model ID used to produce this result. */
    modelId: string;
    /**
     * Method used to compute string offset and length.
     *
     * Possible values: "textElements", "unicodeCodePoint", "utf16CodeUnit"
     */
    stringIndexType: string;
    /**
     * Format of the analyze result top-level content.
     *
     * Possible values: "text", "markdown"
     */
    contentFormat?: string;
    /**
     * Concatenate string representation of all textual and visual elements in reading
     * order.
     */
    content: string;
    /** Analyzed pages. */
    pages: Array<DocumentPageOutput>;
    /** Extracted paragraphs. */
    paragraphs?: Array<DocumentParagraphOutput>;
    /** Extracted tables. */
    tables?: Array<DocumentTableOutput>;
    /** Extracted figures. */
    figures?: Array<DocumentFigureOutput>;
    /** Extracted lists. */
    lists?: Array<DocumentListOutput>;
    /** Extracted sections. */
    sections?: Array<DocumentSectionOutput>;
    /** Extracted key-value pairs. */
    keyValuePairs?: Array<DocumentKeyValuePairOutput>;
    /** Extracted font styles. */
    styles?: Array<DocumentStyleOutput>;
    /** Detected languages. */
    languages?: Array<DocumentLanguageOutput>;
    /** Extracted documents. */
    documents?: Array<DocumentOutput>;
}

/** Request body to authorize document model copy. */
export declare interface AuthorizeCopyRequest {
    /** Unique document model name. */
    modelId: string;
    /** Document model description. */
    description?: string;
    /** List of key-value tag attributes associated with the document model. */
    tags?: Record<string, string>;
}

export declare interface AuthorizeModelCopy {
    /**
     * Generates authorization to copy a document model to this location with
     * specified modelId and optional description.
     */
    post(options: AuthorizeModelCopyParameters): StreamableMethod<AuthorizeModelCopy200Response | AuthorizeModelCopyDefaultResponse>;
}

/** The request has succeeded. */
export declare interface AuthorizeModelCopy200Response extends HttpResponse {
    status: "200";
    body: CopyAuthorizationOutput;
}

export declare interface AuthorizeModelCopyBodyParam {
    /** Authorize copy request parameters. */
    body: AuthorizeCopyRequest;
}

export declare interface AuthorizeModelCopyDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare type AuthorizeModelCopyParameters = AuthorizeModelCopyBodyParam & RequestParameters;

/** Azure Blob Storage content. */
export declare interface AzureBlobContentSource {
    /** Azure Blob Storage container URL. */
    containerUrl: string;
    /** Blob name prefix. */
    prefix?: string;
}

/** Azure Blob Storage content. */
export declare interface AzureBlobContentSourceOutput {
    /** Azure Blob Storage container URL. */
    containerUrl: string;
    /** Blob name prefix. */
    prefix?: string;
}

/** File list in Azure Blob Storage. */
export declare interface AzureBlobFileListContentSource {
    /** Azure Blob Storage container URL. */
    containerUrl: string;
    /** Path to a JSONL file within the container specifying a subset of documents. */
    fileList: string;
}

/** File list in Azure Blob Storage. */
export declare interface AzureBlobFileListContentSourceOutput {
    /** Azure Blob Storage container URL. */
    containerUrl: string;
    /** Path to a JSONL file within the container specifying a subset of documents. */
    fileList: string;
}

/** Bounding polygon on a specific page of the input. */
export declare interface BoundingRegionOutput {
    /** 1-based page number of page containing the bounding region. */
    pageNumber: number;
    /**
     * Bounding polygon on the page, or the entire page if not specified.
     * Coordinates specified relative to the top-left of the page. The numbers
     * represent the x, y values of the polygon vertices, clockwise from the left
     * (-180 degrees inclusive) relative to the element orientation.
     */
    polygon: number[];
}

export declare interface BuildClassifier {
    /** Builds a custom document classifier. */
    post(options: BuildClassifierParameters): StreamableMethod<BuildClassifier202Response | BuildClassifierDefaultResponse>;
}

export declare interface BuildClassifier202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface BuildClassifier202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & BuildClassifier202Headers;
}

export declare interface BuildClassifierBodyParam {
    /** Build request parameters. */
    body: BuildDocumentClassifierRequest;
}

export declare interface BuildClassifierDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

/** The final response for long-running buildClassifier operation */
export declare interface BuildClassifierLogicalResponse extends HttpResponse {
    status: "200";
}

export declare type BuildClassifierParameters = BuildClassifierBodyParam & RequestParameters;

/** Request body to build a new custom document classifier. */
export declare interface BuildDocumentClassifierRequest {
    /** Unique document classifier name. */
    classifierId: string;
    /** Document classifier description. */
    description?: string;
    /** Base classifierId on top of which to train the classifier. */
    baseClassifierId?: string;
    /** List of document types to classify against. */
    docTypes: Record<string, ClassifierDocumentTypeDetails>;
}

/** Request body to build a new custom document model. */
export declare interface BuildDocumentModelRequest {
    /** Unique document model name. */
    modelId: string;
    /** Document model description. */
    description?: string;
    /**
     * Custom document model build mode.
     *
     * Possible values: "template", "neural"
     */
    buildMode: string;
    /**
     * Azure Blob Storage location containing the training data.  Either
     * azureBlobSource or azureBlobFileListSource must be specified.
     */
    azureBlobSource?: AzureBlobContentSource;
    /**
     * Azure Blob Storage file list specifying the training data.  Either
     * azureBlobSource or azureBlobFileListSource must be specified.
     */
    azureBlobFileListSource?: AzureBlobFileListContentSource;
    /** List of key-value tag attributes associated with the document model. */
    tags?: Record<string, string>;
}

export declare interface BuildModel {
    /** Builds a custom document analysis model. */
    post(options: BuildModelParameters): StreamableMethod<BuildModel202Response | BuildModelDefaultResponse>;
}

export declare interface BuildModel202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface BuildModel202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & BuildModel202Headers;
}

export declare interface BuildModelBodyParam {
    /** Build request parameters. */
    body: BuildDocumentModelRequest;
}

export declare interface BuildModelDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

/** The final response for long-running buildModel operation */
export declare interface BuildModelLogicalResponse extends HttpResponse {
    status: "200";
}

export declare type BuildModelParameters = BuildModelBodyParam & RequestParameters;

/** Classifier document type info. */
export declare interface ClassifierDocumentTypeDetails {
    /**
     * Type of training data source.
     *
     * Possible values: "url", "base64", "azureBlob", "azureBlobFileList"
     */
    sourceKind?: string;
    /**
     * Azure Blob Storage location containing the training data for a classifier
     * document type.  Either azureBlobSource or azureBlobFileListSource must be
     * specified.
     */
    azureBlobSource?: AzureBlobContentSource;
    /**
     * Azure Blob Storage file list specifying the training data for a classifier
     * document type.  Either azureBlobSource or azureBlobFileListSource must be
     * specified.
     */
    azureBlobFileListSource?: AzureBlobFileListContentSource;
}

/** Classifier document type info. */
export declare interface ClassifierDocumentTypeDetailsOutput {
    /**
     * Type of training data source.
     *
     * Possible values: "url", "base64", "azureBlob", "azureBlobFileList"
     */
    sourceKind?: string;
    /**
     * Azure Blob Storage location containing the training data for a classifier
     * document type.  Either azureBlobSource or azureBlobFileListSource must be
     * specified.
     */
    azureBlobSource?: AzureBlobContentSourceOutput;
    /**
     * Azure Blob Storage file list specifying the training data for a classifier
     * document type.  Either azureBlobSource or azureBlobFileListSource must be
     * specified.
     */
    azureBlobFileListSource?: AzureBlobFileListContentSourceOutput;
}

export declare interface ClassifyDocument202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface ClassifyDocument202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & ClassifyDocument202Headers;
}

export declare interface ClassifyDocumentBodyParam {
    /** Classify request parameters. */
    body: ClassifyDocumentRequest;
}

export declare interface ClassifyDocumentDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface ClassifyDocumentFromStream {
    /** Classifies document with document classifier. */
    post(options: ClassifyDocumentFromStreamParameters): StreamableMethod<ClassifyDocumentFromStream202Response | ClassifyDocumentFromStreamDefaultResponse>;
    /** Classifies document with document classifier. */
    post(options: ClassifyDocumentParameters): StreamableMethod<ClassifyDocument202Response | ClassifyDocumentDefaultResponse>;
}

export declare interface ClassifyDocumentFromStream202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface ClassifyDocumentFromStream202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & ClassifyDocumentFromStream202Headers;
}

export declare interface ClassifyDocumentFromStreamBodyParam {
    /**
     * Input content.
     *
     * Value may contain any sequence of octets
     */
    body: string | Uint8Array | ReadableStream<Uint8Array> | NodeJS.ReadableStream;
}

export declare interface ClassifyDocumentFromStreamDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

/** The final response for long-running classifyDocumentFromStream operation */
export declare interface ClassifyDocumentFromStreamLogicalResponse extends HttpResponse {
    status: "200";
}

export declare interface ClassifyDocumentFromStreamMediaTypesParam {
    /** Input content type. */
    contentType: "application/octet-stream" | "application/pdf" | "image/jpeg" | "image/png" | "image/tiff" | "image/bmp" | "image/heif" | "text/html" | "application/vnd.openxmlformats-officedocument.wordprocessingml.document" | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" | "application/vnd.openxmlformats-officedocument.presentationml.presentation";
}

export declare type ClassifyDocumentFromStreamParameters = ClassifyDocumentFromStreamQueryParam & ClassifyDocumentFromStreamMediaTypesParam & ClassifyDocumentFromStreamBodyParam & RequestParameters;

export declare interface ClassifyDocumentFromStreamQueryParam {
    queryParameters?: ClassifyDocumentFromStreamQueryParamProperties;
}

export declare interface ClassifyDocumentFromStreamQueryParamProperties {
    /**
     * Method used to compute string offset and length.
     *
     * Possible values: "textElements", "unicodeCodePoint", "utf16CodeUnit"
     */
    stringIndexType?: string;
    /**
     * Document splitting mode.
     *
     * Possible values: "auto", "none", "perPage"
     */
    split?: string;
}

/** The final response for long-running classifyDocument operation */
export declare interface ClassifyDocumentLogicalResponse extends HttpResponse {
    status: "200";
}

export declare interface ClassifyDocumentMediaTypesParam {
    /** Input content type */
    contentType: "application/json";
}

export declare type ClassifyDocumentParameters = ClassifyDocumentQueryParam & ClassifyDocumentMediaTypesParam & ClassifyDocumentBodyParam & RequestParameters;

export declare interface ClassifyDocumentQueryParam {
    queryParameters?: ClassifyDocumentQueryParamProperties;
}

export declare interface ClassifyDocumentQueryParamProperties {
    /**
     * Method used to compute string offset and length.
     *
     * Possible values: "textElements", "unicodeCodePoint", "utf16CodeUnit"
     */
    stringIndexType?: string;
    /**
     * Document splitting mode.
     *
     * Possible values: "auto", "none", "perPage"
     */
    split?: string;
}

/** Document classification parameters. */
export declare interface ClassifyDocumentRequest {
    /** Document URL to classify.  Either urlSource or base64Source must be specified. */
    urlSource?: string;
    /**
     * Base64 encoding of the document to classify.  Either urlSource or base64Source
     * must be specified.
     */
    base64Source?: string;
}

/** Provides the 'x-ms-client-request-id' header to enable request correlation in requests and responses. */
export declare interface ClientRequestIdHeaderOutput {
}

/** A component of a composed document model. */
export declare interface ComponentDocumentModelDetails {
    /** Unique document model name. */
    modelId: string;
}

/** Request body to create a composed document model from component document models. */
export declare interface ComposeDocumentModelRequest {
    /** Unique document model name. */
    modelId: string;
    /** Document model description. */
    description?: string;
    /** List of component document models to compose. */
    componentModels: Array<ComponentDocumentModelDetails>;
    /** List of key-value tag attributes associated with the document model. */
    tags?: Record<string, string>;
}

export declare interface ComposeModel {
    /** Creates a new document model from document types of existing document models. */
    post(options: ComposeModelParameters): StreamableMethod<ComposeModel202Response | ComposeModelDefaultResponse>;
}

export declare interface ComposeModel202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface ComposeModel202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & ComposeModel202Headers;
}

export declare interface ComposeModelBodyParam {
    /** Compose request parameters. */
    body: ComposeDocumentModelRequest;
}

export declare interface ComposeModelDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

/** The final response for long-running composeModel operation */
export declare interface ComposeModelLogicalResponse extends HttpResponse {
    status: "200";
}

export declare type ComposeModelParameters = ComposeModelBodyParam & RequestParameters;

/**
 * Authorization to copy a document model to the specified target resource and
 * modelId.
 */
export declare interface CopyAuthorization {
    /** ID of the target Azure resource where the document model should be copied to. */
    targetResourceId: string;
    /**
     * Location of the target Azure resource where the document model should be copied
     * to.
     */
    targetResourceRegion: string;
    /** Identifier of the target document model. */
    targetModelId: string;
    /** URL of the copied document model in the target account. */
    targetModelLocation: string;
    /** Token used to authorize the request. */
    accessToken: string;
    /** Date/time when the access token expires. */
    expirationDateTime: Date | string;
}

/**
 * Authorization to copy a document model to the specified target resource and
 * modelId.
 */
export declare interface CopyAuthorizationOutput {
    /** ID of the target Azure resource where the document model should be copied to. */
    targetResourceId: string;
    /**
     * Location of the target Azure resource where the document model should be copied
     * to.
     */
    targetResourceRegion: string;
    /** Identifier of the target document model. */
    targetModelId: string;
    /** URL of the copied document model in the target account. */
    targetModelLocation: string;
    /** Token used to authorize the request. */
    accessToken: string;
    /** Date/time when the access token expires. */
    expirationDateTime: string;
}

export declare interface CopyModelTo {
    /** Copies document model to the target resource, region, and modelId. */
    post(options: CopyModelToParameters): StreamableMethod<CopyModelTo202Response | CopyModelToDefaultResponse>;
}

export declare interface CopyModelTo202Headers {
    /** The Retry-After header can indicate how long the client should wait before polling the operation status. */
    "retry-after"?: number;
    "operation-location": string;
}

/** The request has been accepted for processing, but processing has not yet completed. */
export declare interface CopyModelTo202Response extends HttpResponse {
    status: "202";
    headers: RawHttpHeaders & CopyModelTo202Headers;
}

export declare interface CopyModelToBodyParam {
    /** Copy to request parameters. */
    body: CopyAuthorization;
}

export declare interface CopyModelToDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

/** The final response for long-running copyModelTo operation */
export declare interface CopyModelToLogicalResponse extends HttpResponse {
    status: "200";
}

export declare type CopyModelToParameters = CopyModelToBodyParam & RequestParameters;

/**
 * Initialize a new instance of `DocumentIntelligenceClient`
 * @param endpoint - The Document Intelligence service endpoint.
 * @param credentials - uniquely identify client credential
 * @param options - the parameter for all optional parameters
 */
declare function createClient(endpoint: string, credentials: TokenCredential | KeyCredential, options?: ClientOptions): DocumentIntelligenceClient;
export default createClient;

/** Currency field value. */
export declare interface CurrencyValueOutput {
    /** Currency amount. */
    amount: number;
    /** Currency symbol label, if any. */
    currencySymbol?: string;
    /** Resolved currency code (ISO 4217), if any. */
    currencyCode?: string;
}

/** Details regarding custom document models. */
export declare interface CustomDocumentModelsDetailsOutput {
    /** Number of custom document models in the current resource. */
    count: number;
    /** Maximum number of custom document models supported in the current resource. */
    limit: number;
}

export declare interface DeleteClassifier204Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** There is no content to send for this request, but the headers may be useful. */
export declare interface DeleteClassifier204Response extends HttpResponse {
    status: "204";
    headers: RawHttpHeaders & DeleteClassifier204Headers;
}

export declare interface DeleteClassifierDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface DeleteClassifierHeaderParam {
    headers?: RawHttpHeadersInput & DeleteClassifierHeaders;
}

export declare interface DeleteClassifierHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type DeleteClassifierParameters = DeleteClassifierHeaderParam & RequestParameters;

export declare interface DeleteModel204Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** There is no content to send for this request, but the headers may be useful. */
export declare interface DeleteModel204Response extends HttpResponse {
    status: "204";
    headers: RawHttpHeaders & DeleteModel204Headers;
}

export declare interface DeleteModelDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface DeleteModelHeaderParam {
    headers?: RawHttpHeadersInput & DeleteModelHeaders;
}

export declare interface DeleteModelHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type DeleteModelParameters = DeleteModelHeaderParam & RequestParameters;

/** A barcode object. */
export declare interface DocumentBarcodeOutput {
    /**
     * Barcode kind.
     *
     * Possible values: "QRCode", "PDF417", "UPCA", "UPCE", "Code39", "Code128", "EAN8", "EAN13", "DataBar", "Code93", "Codabar", "DataBarExpanded", "ITF", "MicroQRCode", "Aztec", "DataMatrix", "MaxiCode"
     */
    kind: string;
    /** Barcode value. */
    value: string;
    /**
     * Bounding polygon of the barcode, with coordinates specified relative to the
     * top-left of the page. The numbers represent the x, y values of the polygon
     * vertices, clockwise from the left (-180 degrees inclusive) relative to the
     * element orientation.
     */
    polygon?: number[];
    /** Location of the barcode in the reading order concatenated content. */
    span: DocumentSpanOutput;
    /** Confidence of correctly extracting the barcode. */
    confidence: number;
}

/** A caption object describing a table or figure. */
export declare interface DocumentCaptionOutput {
    /** Content of the caption. */
    content: string;
    /** Bounding regions covering the caption. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the caption in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Child elements of the caption. */
    elements?: string[];
}

/** Get Operation response object. */
export declare interface DocumentClassifierBuildOperationDetailsOutput extends OperationDetailsOutputParent {
    /** Operation result upon success. */
    result?: DocumentClassifierDetailsOutput;
    /** Type of operation. */
    kind: "documentClassifierBuild";
}

/** Document classifier info. */
export declare interface DocumentClassifierDetailsOutput {
    /** Unique document classifier name. */
    classifierId: string;
    /** Document classifier description. */
    description?: string;
    /** Date and time (UTC) when the document classifier was created. */
    createdDateTime: string;
    /** Date and time (UTC) when the document classifier will expire. */
    expirationDateTime?: string;
    /** API version used to create this document classifier. */
    apiVersion: string;
    /** Base classifierId on top of which the classifier was trained. */
    baseClassifierId?: string;
    /** List of document types to classify against. */
    docTypes: Record<string, ClassifierDocumentTypeDetailsOutput>;
    /** List of warnings encountered while building the classifier. */
    warnings?: Array<WarningOutput>;
}

/** An object representing the content and location of a field value. */
export declare interface DocumentFieldOutput {
    /**
     * Data type of the field value.
     *
     * Possible values: "string", "date", "time", "phoneNumber", "number", "integer", "selectionMark", "countryRegion", "signature", "array", "object", "currency", "address", "boolean", "selectionGroup"
     */
    type: string;
    /** String value. */
    valueString?: string;
    /** Date value in YYYY-MM-DD format (ISO 8601). */
    valueDate?: string;
    /** Time value in hh:mm:ss format (ISO 8601). */
    valueTime?: string;
    /** Phone number value in E.164 format (ex. +19876543210). */
    valuePhoneNumber?: string;
    /** Floating point value. */
    valueNumber?: number;
    /** Integer value. */
    valueInteger?: number;
    /**
     * Selection mark value.
     *
     * Possible values: "selected", "unselected"
     */
    valueSelectionMark?: string;
    /**
     * Presence of signature.
     *
     * Possible values: "signed", "unsigned"
     */
    valueSignature?: string;
    /** 3-letter country code value (ISO 3166-1 alpha-3). */
    valueCountryRegion?: string;
    /** Array of field values. */
    valueArray?: Array<DocumentFieldOutput>;
    /** Dictionary of named field values. */
    valueObject?: Record<string, DocumentFieldOutput>;
    /** Currency value. */
    valueCurrency?: CurrencyValueOutput;
    /** Address value. */
    valueAddress?: AddressValueOutput;
    /** Boolean value. */
    valueBoolean?: boolean;
    /** Selection group value. */
    valueSelectionGroup?: string[];
    /** Field content. */
    content?: string;
    /** Bounding regions covering the field. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the field in the reading order concatenated content. */
    spans?: Array<DocumentSpanOutput>;
    /** Confidence of correctly extracting the field. */
    confidence?: number;
}

/** Description of the field semantic schema using a JSON Schema style syntax. */
export declare interface DocumentFieldSchemaOutput {
    /**
     * Semantic data type of the field value.
     *
     * Possible values: "string", "date", "time", "phoneNumber", "number", "integer", "selectionMark", "countryRegion", "signature", "array", "object", "currency", "address", "boolean", "selectionGroup"
     */
    type: string;
    /** Field description. */
    description?: string;
    /** Example field content. */
    example?: string;
    /** Field type schema of each array element. */
    items?: DocumentFieldSchemaOutput;
    /** Named sub-fields of the object field. */
    properties?: Record<string, DocumentFieldSchemaOutput>;
}

/** An object representing a figure in the document. */
export declare interface DocumentFigureOutput {
    /** Bounding regions covering the figure. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the figure in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Child elements of the figure, excluding any caption or footnotes. */
    elements?: string[];
    /** Caption associated with the figure. */
    caption?: DocumentCaptionOutput;
    /** List of footnotes associated with the figure. */
    footnotes?: Array<DocumentFootnoteOutput>;
}

/** A footnote object describing a table or figure. */
export declare interface DocumentFootnoteOutput {
    /** Content of the footnote. */
    content: string;
    /** Bounding regions covering the footnote. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the footnote in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Child elements of the footnote. */
    elements?: string[];
}

/** A formula object. */
export declare interface DocumentFormulaOutput {
    /**
     * Formula kind.
     *
     * Possible values: "inline", "display"
     */
    kind: string;
    /** LaTex expression describing the formula. */
    value: string;
    /**
     * Bounding polygon of the formula, with coordinates specified relative to the
     * top-left of the page. The numbers represent the x, y values of the polygon
     * vertices, clockwise from the left (-180 degrees inclusive) relative to the
     * element orientation.
     */
    polygon?: number[];
    /** Location of the formula in the reading order concatenated content. */
    span: DocumentSpanOutput;
    /** Confidence of correctly extracting the formula. */
    confidence: number;
}

export declare type DocumentIntelligenceClient = Client & {
    path: Routes;
};

/** An object representing the field key or value in a key-value pair. */
export declare interface DocumentKeyValueElementOutput {
    /** Concatenated content of the key-value element in reading order. */
    content: string;
    /** Bounding regions covering the key-value element. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the key-value element in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
}

/**
 * An object representing a form field with distinct field label (key) and field
 * value (may be empty).
 */
export declare interface DocumentKeyValuePairOutput {
    /** Field label of the key-value pair. */
    key: DocumentKeyValueElementOutput;
    /** Field value of the key-value pair. */
    value?: DocumentKeyValueElementOutput;
    /** Confidence of correctly extracting the key-value pair. */
    confidence: number;
}

/** An object representing the detected language for a given text span. */
export declare interface DocumentLanguageOutput {
    /**
     * Detected language.  Value may an ISO 639-1 language code (ex. "en", "fr")
     * or BCP 47 language tag (ex. "zh-Hans").
     */
    locale: string;
    /**
     * Location of the text elements in the concatenated content the language applies
     * to.
     */
    spans: Array<DocumentSpanOutput>;
    /** Confidence of correctly identifying the language. */
    confidence: number;
}

/**
 * A content line object consisting of an adjacent sequence of content elements,
 * such as words and selection marks.
 */
export declare interface DocumentLineOutput {
    /** Concatenated content of the contained elements in reading order. */
    content: string;
    /**
     * Bounding polygon of the line, with coordinates specified relative to the
     * top-left of the page. The numbers represent the x, y values of the polygon
     * vertices, clockwise from the left (-180 degrees inclusive) relative to the
     * element orientation.
     */
    polygon?: number[];
    /** Location of the line in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
}

/** An object representing a list item in the document. */
export declare interface DocumentListItemOutput {
    /** Level of the list item (1-indexed). */
    level: number;
    /** Content of the list item. */
    content: string;
    /** Bounding regions covering the list item. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the list item in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Child elements of the list item. */
    elements?: string[];
}

/** An object representing a list in the document. */
export declare interface DocumentListOutput {
    /** Location of the list in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Items in the list. */
    items: Array<DocumentListItemOutput>;
}

/** Get Operation response object. */
export declare interface DocumentModelBuildOperationDetailsOutput extends OperationDetailsOutputParent {
    /** Operation result upon success. */
    result?: DocumentModelDetailsOutput;
    /** Type of operation. */
    kind: "documentModelBuild";
}

/** Get Operation response object. */
export declare interface DocumentModelComposeOperationDetailsOutput extends OperationDetailsOutputParent {
    /** Operation result upon success. */
    result?: DocumentModelDetailsOutput;
    /** Type of operation. */
    kind: "documentModelCompose";
}

/** Get Operation response object. */
export declare interface DocumentModelCopyToOperationDetailsOutput extends OperationDetailsOutputParent {
    /** Operation result upon success. */
    result?: DocumentModelDetailsOutput;
    /** Type of operation. */
    kind: "documentModelCopyTo";
}

/** Document model info. */
export declare interface DocumentModelDetailsOutput {
    /** Unique document model name. */
    modelId: string;
    /** Document model description. */
    description?: string;
    /** Date and time (UTC) when the document model was created. */
    createdDateTime: string;
    /** Date and time (UTC) when the document model will expire. */
    expirationDateTime?: string;
    /** API version used to create this document model. */
    apiVersion?: string;
    /** List of key-value tag attributes associated with the document model. */
    tags?: Record<string, string>;
    /**
     * Custom document model build mode.
     *
     * Possible values: "template", "neural"
     */
    buildMode?: string;
    /**
     * Azure Blob Storage location containing the training data.  Either
     * azureBlobSource or azureBlobFileListSource must be specified.
     */
    azureBlobSource?: AzureBlobContentSourceOutput;
    /**
     * Azure Blob Storage file list specifying the training data.  Either
     * azureBlobSource or azureBlobFileListSource must be specified.
     */
    azureBlobFileListSource?: AzureBlobFileListContentSourceOutput;
    /** Supported document types. */
    docTypes?: Record<string, DocumentTypeDetailsOutput>;
    /** List of warnings encountered while building the model. */
    warnings?: Array<WarningOutput>;
}

/** An object describing the location and semantic content of a document. */
export declare interface DocumentOutput {
    /** Document type. */
    docType: string;
    /** Bounding regions covering the document. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the document in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Dictionary of named field values. */
    fields?: Record<string, DocumentFieldOutput>;
    /** Confidence of correctly extracting the document. */
    confidence: number;
}

/** Content and layout elements extracted from a page from the input. */
export declare interface DocumentPageOutput {
    /** 1-based page number in the input document. */
    pageNumber: number;
    /**
     * The general orientation of the content in clockwise direction, measured in
     * degrees between (-180, 180].
     */
    angle?: number;
    /** The width of the image/PDF in pixels/inches, respectively. */
    width?: number;
    /** The height of the image/PDF in pixels/inches, respectively. */
    height?: number;
    /**
     * The unit used by the width, height, and polygon properties. For images, the
     * unit is "pixel". For PDF, the unit is "inch".
     *
     * Possible values: "pixel", "inch"
     */
    unit?: string;
    /** Location of the page in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Extracted words from the page. */
    words?: Array<DocumentWordOutput>;
    /** Extracted selection marks from the page. */
    selectionMarks?: Array<DocumentSelectionMarkOutput>;
    /**
     * Extracted lines from the page, potentially containing both textual and visual
     * elements.
     */
    lines?: Array<DocumentLineOutput>;
    /** Extracted barcodes from the page. */
    barcodes?: Array<DocumentBarcodeOutput>;
    /** Extracted formulas from the page. */
    formulas?: Array<DocumentFormulaOutput>;
}

/**
 * A paragraph object consisting with contiguous lines generally with common
 * alignment and spacing.
 */
export declare interface DocumentParagraphOutput {
    /**
     * Semantic role of the paragraph.
     *
     * Possible values: "pageHeader", "pageFooter", "pageNumber", "title", "sectionHeading", "footnote", "formulaBlock"
     */
    role?: string;
    /** Concatenated content of the paragraph in reading order. */
    content: string;
    /** Bounding regions covering the paragraph. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the paragraph in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
}

/** An object representing a section in the document. */
export declare interface DocumentSectionOutput {
    /** Location of the section in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Child elements of the section. */
    elements?: string[];
}

/**
 * A selection mark object representing check boxes, radio buttons, and other
 * elements indicating a selection.
 */
export declare interface DocumentSelectionMarkOutput {
    /**
     * State of the selection mark.
     *
     * Possible values: "selected", "unselected"
     */
    state: string;
    /**
     * Bounding polygon of the selection mark, with coordinates specified relative
     * to the top-left of the page. The numbers represent the x, y values of the
     * polygon vertices, clockwise from the left (-180 degrees inclusive) relative
     * to the element orientation.
     */
    polygon?: number[];
    /** Location of the selection mark in the reading order concatenated content. */
    span: DocumentSpanOutput;
    /** Confidence of correctly extracting the selection mark. */
    confidence: number;
}

/**
 * Contiguous region of the concatenated content property, specified as an offset
 * and length.
 */
export declare interface DocumentSpanOutput {
    /** Zero-based index of the content represented by the span. */
    offset: number;
    /** Number of characters in the content represented by the span. */
    length: number;
}

/** An object representing observed text styles. */
export declare interface DocumentStyleOutput {
    /** Is content handwritten? */
    isHandwritten?: boolean;
    /**
     * Visually most similar font from among the set of supported font families, with
     * fallback fonts following CSS convention (ex. 'Arial, sans-serif').
     */
    similarFontFamily?: string;
    /**
     * Font style.
     *
     * Possible values: "normal", "italic"
     */
    fontStyle?: string;
    /**
     * Font weight.
     *
     * Possible values: "normal", "bold"
     */
    fontWeight?: string;
    /** Foreground color in #rrggbb hexadecimal format. */
    color?: string;
    /** Background color in #rrggbb hexadecimal format.. */
    backgroundColor?: string;
    /** Location of the text elements in the concatenated content the style applies to. */
    spans: Array<DocumentSpanOutput>;
    /** Confidence of correctly identifying the style. */
    confidence: number;
}

/** An object representing the location and content of a table cell. */
export declare interface DocumentTableCellOutput {
    /**
     * Table cell kind.
     *
     * Possible values: "content", "rowHeader", "columnHeader", "stubHead", "description"
     */
    kind?: string;
    /** Row index of the cell. */
    rowIndex: number;
    /** Column index of the cell. */
    columnIndex: number;
    /** Number of rows spanned by this cell. */
    rowSpan?: number;
    /** Number of columns spanned by this cell. */
    columnSpan?: number;
    /** Concatenated content of the table cell in reading order. */
    content: string;
    /** Bounding regions covering the table cell. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the table cell in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Child elements of the table cell. */
    elements?: string[];
}

/** A table object consisting table cells arranged in a rectangular layout. */
export declare interface DocumentTableOutput {
    /** Number of rows in the table. */
    rowCount: number;
    /** Number of columns in the table. */
    columnCount: number;
    /** Cells contained within the table. */
    cells: Array<DocumentTableCellOutput>;
    /** Bounding regions covering the table. */
    boundingRegions?: Array<BoundingRegionOutput>;
    /** Location of the table in the reading order concatenated content. */
    spans: Array<DocumentSpanOutput>;
    /** Caption associated with the table. */
    caption?: DocumentCaptionOutput;
    /** List of footnotes associated with the table. */
    footnotes?: Array<DocumentFootnoteOutput>;
}

/** Document type info. */
export declare interface DocumentTypeDetailsOutput {
    /** Document model description. */
    description?: string;
    /**
     * Custom document model build mode.
     *
     * Possible values: "template", "neural"
     */
    buildMode?: string;
    /** Description of the document semantic schema using a JSON Schema style syntax. */
    fieldSchema: Record<string, DocumentFieldSchemaOutput>;
    /** Estimated confidence for each field. */
    fieldConfidence?: Record<string, number>;
}

/**
 * A word object consisting of a contiguous sequence of characters.  For non-space
 * delimited languages, such as Chinese, Japanese, and Korean, each character is
 * represented as its own word.
 */
export declare interface DocumentWordOutput {
    /** Text content of the word. */
    content: string;
    /**
     * Bounding polygon of the word, with coordinates specified relative to the
     * top-left of the page. The numbers represent the x, y values of the polygon
     * vertices, clockwise from the left (-180 degrees inclusive) relative to the
     * element orientation.
     */
    polygon?: number[];
    /** Location of the word in the reading order concatenated content. */
    span: DocumentSpanOutput;
    /** Confidence of correctly extracting the word. */
    confidence: number;
}

/** The error object. */
export declare interface ErrorModelOutput {
    /** One of a server-defined set of error codes. */
    code: string;
    /** A human-readable representation of the error. */
    message: string;
    /** The target of the error. */
    target?: string;
    /** An array of details about specific errors that led to this reported error. */
    details?: Array<ErrorModelOutput>;
    /** An object containing more specific information than the current object about the error. */
    innererror?: InnerErrorOutput;
}

/** Error response object. */
export declare interface ErrorResponseOutput {
    /** Error info. */
    error: ErrorModelOutput;
}

export declare interface GetAnalyzeResult {
    /** Gets the result of document analysis. */
    get(options?: GetAnalyzeResultParameters): StreamableMethod<GetAnalyzeResult200Response | GetAnalyzeResultDefaultResponse>;
}

/** The request has succeeded. */
export declare interface GetAnalyzeResult200Response extends HttpResponse {
    status: "200";
    body: AnalyzeResultOperationOutput;
}

export declare interface GetAnalyzeResultDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare type GetAnalyzeResultParameters = RequestParameters;

/**
 * Helper type to extract the type of an array
 */
export declare type GetArrayType<T> = T extends Array<infer TData> ? TData : never;

export declare interface GetClassifier {
    /** Gets detailed document classifier information. */
    get(options?: GetClassifierParameters): StreamableMethod<GetClassifier200Response | GetClassifierDefaultResponse>;
    /** Deletes document classifier. */
    delete(options?: DeleteClassifierParameters): StreamableMethod<DeleteClassifier204Response | DeleteClassifierDefaultResponse>;
}

export declare interface GetClassifier200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetClassifier200Response extends HttpResponse {
    status: "200";
    body: DocumentClassifierDetailsOutput;
    headers: RawHttpHeaders & GetClassifier200Headers;
}

export declare interface GetClassifierDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetClassifierHeaderParam {
    headers?: RawHttpHeadersInput & GetClassifierHeaders;
}

export declare interface GetClassifierHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetClassifierParameters = GetClassifierHeaderParam & RequestParameters;

export declare interface GetClassifyResult {
    /** Gets the result of document classifier. */
    get(options?: GetClassifyResultParameters): StreamableMethod<GetClassifyResult200Response | GetClassifyResultDefaultResponse>;
}

/** The request has succeeded. */
export declare interface GetClassifyResult200Response extends HttpResponse {
    status: "200";
    body: AnalyzeResultOperationOutput;
}

export declare interface GetClassifyResultDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare type GetClassifyResultParameters = RequestParameters;

export declare interface GetDocumentClassifierBuildOperation200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetDocumentClassifierBuildOperation200Response extends HttpResponse {
    status: "200";
    body: DocumentClassifierBuildOperationDetailsOutput;
    headers: RawHttpHeaders & GetDocumentClassifierBuildOperation200Headers;
}

export declare interface GetDocumentClassifierBuildOperationDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetDocumentClassifierBuildOperationHeaderParam {
    headers?: RawHttpHeadersInput & GetDocumentClassifierBuildOperationHeaders;
}

export declare interface GetDocumentClassifierBuildOperationHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetDocumentClassifierBuildOperationParameters = GetDocumentClassifierBuildOperationHeaderParam & RequestParameters;

export declare interface GetDocumentModelBuildOperation {
    /** Gets operation info. */
    get(options?: GetDocumentModelBuildOperationParameters): StreamableMethod<GetDocumentModelBuildOperation200Response | GetDocumentModelBuildOperationDefaultResponse>;
    /** Gets operation info. */
    get(options?: GetDocumentModelComposeOperationParameters): StreamableMethod<GetDocumentModelComposeOperation200Response | GetDocumentModelComposeOperationDefaultResponse>;
    /** Gets operation info. */
    get(options?: GetDocumentModelCopyToOperationParameters): StreamableMethod<GetDocumentModelCopyToOperation200Response | GetDocumentModelCopyToOperationDefaultResponse>;
    /** Gets operation info. */
    get(options?: GetDocumentClassifierBuildOperationParameters): StreamableMethod<GetDocumentClassifierBuildOperation200Response | GetDocumentClassifierBuildOperationDefaultResponse>;
    /** Gets operation info. */
    get(options?: GetOperationParameters): StreamableMethod<GetOperation200Response | GetOperationDefaultResponse>;
}

export declare interface GetDocumentModelBuildOperation200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetDocumentModelBuildOperation200Response extends HttpResponse {
    status: "200";
    body: DocumentModelBuildOperationDetailsOutput;
    headers: RawHttpHeaders & GetDocumentModelBuildOperation200Headers;
}

export declare interface GetDocumentModelBuildOperationDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetDocumentModelBuildOperationHeaderParam {
    headers?: RawHttpHeadersInput & GetDocumentModelBuildOperationHeaders;
}

export declare interface GetDocumentModelBuildOperationHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetDocumentModelBuildOperationParameters = GetDocumentModelBuildOperationHeaderParam & RequestParameters;

export declare interface GetDocumentModelComposeOperation200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetDocumentModelComposeOperation200Response extends HttpResponse {
    status: "200";
    body: DocumentModelComposeOperationDetailsOutput;
    headers: RawHttpHeaders & GetDocumentModelComposeOperation200Headers;
}

export declare interface GetDocumentModelComposeOperationDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetDocumentModelComposeOperationHeaderParam {
    headers?: RawHttpHeadersInput & GetDocumentModelComposeOperationHeaders;
}

export declare interface GetDocumentModelComposeOperationHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetDocumentModelComposeOperationParameters = GetDocumentModelComposeOperationHeaderParam & RequestParameters;

export declare interface GetDocumentModelCopyToOperation200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetDocumentModelCopyToOperation200Response extends HttpResponse {
    status: "200";
    body: DocumentModelCopyToOperationDetailsOutput;
    headers: RawHttpHeaders & GetDocumentModelCopyToOperation200Headers;
}

export declare interface GetDocumentModelCopyToOperationDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetDocumentModelCopyToOperationHeaderParam {
    headers?: RawHttpHeadersInput & GetDocumentModelCopyToOperationHeaders;
}

export declare interface GetDocumentModelCopyToOperationHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetDocumentModelCopyToOperationParameters = GetDocumentModelCopyToOperationHeaderParam & RequestParameters;

/**
 * Helper function that builds a Poller object to help polling a long running operation.
 * @param client - Client to use for sending the request to get additional pages.
 * @param initialResponse - The initial response.
 * @param options - Options to set a resume state or custom polling interval.
 * @returns - A poller object to poll for operation state updates and eventually get the final response.
 */
export declare function getLongRunningPoller<TResult extends BuildModelLogicalResponse | BuildModelDefaultResponse>(client: Client, initialResponse: BuildModel202Response | BuildModelDefaultResponse, options?: CreateHttpPollerOptions<TResult, OperationState<TResult>>): Promise<SimplePollerLike<OperationState<TResult>, TResult>>;

export declare function getLongRunningPoller<TResult extends ComposeModelLogicalResponse | ComposeModelDefaultResponse>(client: Client, initialResponse: ComposeModel202Response | ComposeModelDefaultResponse, options?: CreateHttpPollerOptions<TResult, OperationState<TResult>>): Promise<SimplePollerLike<OperationState<TResult>, TResult>>;

export declare function getLongRunningPoller<TResult extends CopyModelToLogicalResponse | CopyModelToDefaultResponse>(client: Client, initialResponse: CopyModelTo202Response | CopyModelToDefaultResponse, options?: CreateHttpPollerOptions<TResult, OperationState<TResult>>): Promise<SimplePollerLike<OperationState<TResult>, TResult>>;

export declare function getLongRunningPoller<TResult extends BuildClassifierLogicalResponse | BuildClassifierDefaultResponse>(client: Client, initialResponse: BuildClassifier202Response | BuildClassifierDefaultResponse, options?: CreateHttpPollerOptions<TResult, OperationState<TResult>>): Promise<SimplePollerLike<OperationState<TResult>, TResult>>;

export declare function getLongRunningPoller<TResult extends AnalyzeDocumentFromStreamLogicalResponse | AnalyzeDocumentFromStreamDefaultResponse>(client: Client, initialResponse: AnalyzeDocumentFromStream202Response | AnalyzeDocumentFromStreamDefaultResponse, options?: CreateHttpPollerOptions<TResult, OperationState<TResult>>): Promise<SimplePollerLike<OperationState<TResult>, TResult>>;

export declare function getLongRunningPoller<TResult extends ClassifyDocumentFromStreamLogicalResponse | ClassifyDocumentFromStreamDefaultResponse>(client: Client, initialResponse: ClassifyDocumentFromStream202Response | ClassifyDocumentFromStreamDefaultResponse, options?: CreateHttpPollerOptions<TResult, OperationState<TResult>>): Promise<SimplePollerLike<OperationState<TResult>, TResult>>;

export declare interface GetModel {
    /** Gets detailed document model information. */
    get(options?: GetModelParameters): StreamableMethod<GetModel200Response | GetModelDefaultResponse>;
    /** Deletes document model. */
    delete(options?: DeleteModelParameters): StreamableMethod<DeleteModel204Response | DeleteModelDefaultResponse>;
}

export declare interface GetModel200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetModel200Response extends HttpResponse {
    status: "200";
    body: DocumentModelDetailsOutput;
    headers: RawHttpHeaders & GetModel200Headers;
}

export declare interface GetModelDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetModelHeaderParam {
    headers?: RawHttpHeadersInput & GetModelHeaders;
}

export declare interface GetModelHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetModelParameters = GetModelHeaderParam & RequestParameters;

export declare interface GetOperation200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface GetOperation200Response extends HttpResponse {
    status: "200";
    body: OperationDetailsOutput;
    headers: RawHttpHeaders & GetOperation200Headers;
}

export declare interface GetOperationDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface GetOperationHeaderParam {
    headers?: RawHttpHeadersInput & GetOperationHeaders;
}

export declare interface GetOperationHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type GetOperationParameters = GetOperationHeaderParam & RequestParameters;

/**
 * The type of a custom function that defines how to get a page and a link to the next one if any.
 */
export declare type GetPage<TPage> = (pageLink: string, maxPageSize?: number) => Promise<{
    page: TPage;
    nextPageLink?: string;
}>;

export declare interface GetResourceInfo {
    /** Return information about the current resource. */
    get(options?: GetResourceInfoParameters): StreamableMethod<GetResourceInfo200Response | GetResourceInfoDefaultResponse>;
}

/** The request has succeeded. */
export declare interface GetResourceInfo200Response extends HttpResponse {
    status: "200";
    body: ResourceDetailsOutput;
}

export declare interface GetResourceInfoDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare type GetResourceInfoParameters = RequestParameters;

/** An object containing more specific information about the error. */
export declare interface InnerErrorOutput {
    /** One of a server-defined set of error codes. */
    code?: string;
    /** A human-readable representation of the error. */
    message?: string;
    /** Inner error. */
    innererror?: InnerErrorOutput;
}

export declare function isUnexpected(response: ListOperations200Response | ListOperationsDefaultResponse): response is ListOperationsDefaultResponse;

export declare function isUnexpected(response: GetDocumentModelBuildOperation200Response | GetDocumentModelComposeOperation200Response | GetDocumentModelCopyToOperation200Response | GetDocumentClassifierBuildOperation200Response | GetOperation200Response | GetDocumentModelBuildOperationDefaultResponse): response is GetDocumentModelBuildOperationDefaultResponse;

export declare function isUnexpected(response: GetResourceInfo200Response | GetResourceInfoDefaultResponse): response is GetResourceInfoDefaultResponse;

export declare function isUnexpected(response: GetAnalyzeResult200Response | GetAnalyzeResultDefaultResponse): response is GetAnalyzeResultDefaultResponse;

export declare function isUnexpected(response: AnalyzeDocumentFromStream202Response | AnalyzeDocument202Response | AnalyzeDocumentFromStreamLogicalResponse | AnalyzeDocumentLogicalResponse | AnalyzeDocumentFromStreamDefaultResponse): response is AnalyzeDocumentFromStreamDefaultResponse;

export declare function isUnexpected(response: GetModel200Response | GetModelDefaultResponse): response is GetModelDefaultResponse;

export declare function isUnexpected(response: DeleteModel204Response | DeleteModelDefaultResponse): response is DeleteModelDefaultResponse;

export declare function isUnexpected(response: BuildModel202Response | BuildModelLogicalResponse | BuildModelDefaultResponse): response is BuildModelDefaultResponse;

export declare function isUnexpected(response: ComposeModel202Response | ComposeModelLogicalResponse | ComposeModelDefaultResponse): response is ComposeModelDefaultResponse;

export declare function isUnexpected(response: AuthorizeModelCopy200Response | AuthorizeModelCopyDefaultResponse): response is AuthorizeModelCopyDefaultResponse;

export declare function isUnexpected(response: CopyModelTo202Response | CopyModelToLogicalResponse | CopyModelToDefaultResponse): response is CopyModelToDefaultResponse;

export declare function isUnexpected(response: ListModels200Response | ListModelsDefaultResponse): response is ListModelsDefaultResponse;

export declare function isUnexpected(response: BuildClassifier202Response | BuildClassifierLogicalResponse | BuildClassifierDefaultResponse): response is BuildClassifierDefaultResponse;

export declare function isUnexpected(response: ListClassifiers200Response | ListClassifiersDefaultResponse): response is ListClassifiersDefaultResponse;

export declare function isUnexpected(response: GetClassifier200Response | GetClassifierDefaultResponse): response is GetClassifierDefaultResponse;

export declare function isUnexpected(response: DeleteClassifier204Response | DeleteClassifierDefaultResponse): response is DeleteClassifierDefaultResponse;

export declare function isUnexpected(response: ClassifyDocumentFromStream202Response | ClassifyDocument202Response | ClassifyDocumentFromStreamLogicalResponse | ClassifyDocumentLogicalResponse | ClassifyDocumentFromStreamDefaultResponse): response is ClassifyDocumentFromStreamDefaultResponse;

export declare function isUnexpected(response: GetClassifyResult200Response | GetClassifyResultDefaultResponse): response is GetClassifyResultDefaultResponse;

export declare interface ListClassifiers {
    /** List all document classifiers. */
    get(options?: ListClassifiersParameters): StreamableMethod<ListClassifiers200Response | ListClassifiersDefaultResponse>;
}

export declare interface ListClassifiers200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface ListClassifiers200Response extends HttpResponse {
    status: "200";
    body: PagedDocumentClassifierDetailsOutput;
    headers: RawHttpHeaders & ListClassifiers200Headers;
}

export declare interface ListClassifiersDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface ListClassifiersHeaderParam {
    headers?: RawHttpHeadersInput & ListClassifiersHeaders;
}

export declare interface ListClassifiersHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type ListClassifiersParameters = ListClassifiersHeaderParam & RequestParameters;

export declare interface ListModels {
    /** List all document models */
    get(options?: ListModelsParameters): StreamableMethod<ListModels200Response | ListModelsDefaultResponse>;
}

export declare interface ListModels200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface ListModels200Response extends HttpResponse {
    status: "200";
    body: PagedDocumentModelDetailsOutput;
    headers: RawHttpHeaders & ListModels200Headers;
}

export declare interface ListModelsDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface ListModelsHeaderParam {
    headers?: RawHttpHeadersInput & ListModelsHeaders;
}

export declare interface ListModelsHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type ListModelsParameters = ListModelsHeaderParam & RequestParameters;

export declare interface ListOperations {
    /** Lists all operations. */
    get(options?: ListOperationsParameters): StreamableMethod<ListOperations200Response | ListOperationsDefaultResponse>;
}

export declare interface ListOperations200Headers {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

/** The request has succeeded. */
export declare interface ListOperations200Response extends HttpResponse {
    status: "200";
    body: PagedOperationDetailsOutput;
    headers: RawHttpHeaders & ListOperations200Headers;
}

export declare interface ListOperationsDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface ListOperationsHeaderParam {
    headers?: RawHttpHeadersInput & ListOperationsHeaders;
}

export declare interface ListOperationsHeaders {
    /** An opaque, globally-unique, client-generated string identifier for the request. */
    "x-ms-client-request-id"?: string;
}

export declare type ListOperationsParameters = ListOperationsHeaderParam & RequestParameters;

/** Operation info. */
export declare type OperationDetailsOutput = OperationDetailsOutputParent | DocumentModelBuildOperationDetailsOutput | DocumentModelComposeOperationDetailsOutput | DocumentModelCopyToOperationDetailsOutput | DocumentClassifierBuildOperationDetailsOutput;

/** Operation info. */
export declare interface OperationDetailsOutputParent {
    /** Operation ID */
    operationId: string;
    /**
     * Operation status.  notStarted, running, completed, or failed
     *
     * Possible values: "notStarted", "running", "failed", "succeeded", "completed", "canceled"
     */
    status: string;
    /** Operation progress (0-100). */
    percentCompleted?: number;
    /** Date and time (UTC) when the operation was created. */
    createdDateTime: string;
    /** Date and time (UTC) when the status was last updated. */
    lastUpdatedDateTime: string;
    /** URL of the resource targeted by this operation. */
    resourceLocation: string;
    /** API version used to create this operation. */
    apiVersion?: string;
    /** List of key-value tag attributes associated with the document model. */
    tags?: Record<string, string>;
    /** Encountered error. */
    error?: ErrorModelOutput;
    kind: string;
}

/** Paged collection of DocumentClassifierDetails items */
export declare type PagedDocumentClassifierDetailsOutput = Paged<DocumentClassifierDetailsOutput>;

/** Paged collection of DocumentModelDetails items */
export declare type PagedDocumentModelDetailsOutput = Paged<DocumentModelDetailsOutput>;

/** Paged collection of OperationDetails items */
export declare type PagedOperationDetailsOutput = Paged<OperationDetailsOutput>;

/**
 * Helper to paginate results from an initial response that follows the specification of Autorest `x-ms-pageable` extension
 * @param client - Client to use for sending the next page requests
 * @param initialResponse - Initial response containing the nextLink and current page of elements
 * @param customGetPage - Optional - Function to define how to extract the page and next link to be used to paginate the results
 * @returns - PagedAsyncIterableIterator to iterate the elements
 */
export declare function paginate<TResponse extends PathUncheckedResponse>(client: Client, initialResponse: TResponse, options?: PagingOptions<TResponse>): PagedAsyncIterableIterator<PaginateReturn<TResponse>>;

/**
 * Helper type to infer the Type of the paged elements from the response type
 * This type is generated based on the swagger information for x-ms-pageable
 * specifically on the itemName property which indicates the property of the response
 * where the page items are found. The default value is `value`.
 * This type will allow us to provide strongly typed Iterator based on the response we get as second parameter
 */
export declare type PaginateReturn<TResult> = TResult extends {
    body: {
        value?: infer TPage;
    };
} ? GetArrayType<TPage> : Array<unknown>;

/**
 * Options for the paging helper
 */
export declare interface PagingOptions<TResponse> {
    /**
     * Custom function to extract pagination details for crating the PagedAsyncIterableIterator
     */
    customGetPage?: GetPage<PaginateReturn<TResponse>[]>;
}

/** Quota used, limit, and next reset date/time. */
export declare interface QuotaDetailsOutput {
    /** Amount of the resource quota used. */
    used: number;
    /** Resource quota limit. */
    quota: number;
    /** Date/time when the resource quota usage will be reset. */
    quotaResetDateTime: string;
}

/** General information regarding the current resource. */
export declare interface ResourceDetailsOutput {
    /** Details regarding custom document models. */
    customDocumentModels: CustomDocumentModelsDetailsOutput;
    /** Quota used, limit, and next reset date/time. */
    customNeuralDocumentModelBuilds: QuotaDetailsOutput;
}

export declare interface Routes {
    /** Resource for '/operations' has methods for the following verbs: get */
    (path: "/operations"): ListOperations;
    /** Resource for '/operations/\{operationId\}' has methods for the following verbs: get */
    (path: "/operations/{operationId}", operationId: string): GetDocumentModelBuildOperation;
    /** Resource for '/info' has methods for the following verbs: get */
    (path: "/info"): GetResourceInfo;
    /** Resource for '/documentModels/\{modelId\}/analyzeResults/\{resultId\}' has methods for the following verbs: get */
    (path: "/documentModels/{modelId}/analyzeResults/{resultId}", modelId: string, resultId: string): GetAnalyzeResult;
    /** Resource for '/documentModels/\{modelId\}:analyze' has methods for the following verbs: post */
    (path: "/documentModels/{modelId}:analyze", modelId: string): AnalyzeDocumentFromStream;
    /** Resource for '/documentModels/\{modelId\}' has methods for the following verbs: get, delete */
    (path: "/documentModels/{modelId}", modelId: string): GetModel;
    /** Resource for '/documentModels:build' has methods for the following verbs: post */
    (path: "/documentModels:build"): BuildModel;
    /** Resource for '/documentModels:compose' has methods for the following verbs: post */
    (path: "/documentModels:compose"): ComposeModel;
    /** Resource for '/documentModels:authorizeCopy' has methods for the following verbs: post */
    (path: "/documentModels:authorizeCopy"): AuthorizeModelCopy;
    /** Resource for '/documentModels/\{modelId\}:copyTo' has methods for the following verbs: post */
    (path: "/documentModels/{modelId}:copyTo", modelId: string): CopyModelTo;
    /** Resource for '/documentModels' has methods for the following verbs: get */
    (path: "/documentModels"): ListModels;
    /** Resource for '/documentClassifiers:build' has methods for the following verbs: post */
    (path: "/documentClassifiers:build"): BuildClassifier;
    /** Resource for '/documentClassifiers' has methods for the following verbs: get */
    (path: "/documentClassifiers"): ListClassifiers;
    /** Resource for '/documentClassifiers/\{classifierId\}' has methods for the following verbs: get, delete */
    (path: "/documentClassifiers/{classifierId}", classifierId: string): GetClassifier;
    /** Resource for '/documentClassifiers/\{classifierId\}:analyze' has methods for the following verbs: post */
    (path: "/documentClassifiers/{classifierId}:analyze", classifierId: string): ClassifyDocumentFromStream;
    /** Resource for '/documentClassifiers/\{classifierId\}/analyzeResults/\{resultId\}' has methods for the following verbs: get */
    (path: "/documentClassifiers/{classifierId}/analyzeResults/{resultId}", classifierId: string, resultId: string): GetClassifyResult;
}

/** The error object. */
export declare interface WarningOutput {
    /** One of a server-defined set of warning codes. */
    code: string;
    /** A human-readable representation of the warning. */
    message: string;
    /** The target of the error. */
    target?: string;
}

export { }
